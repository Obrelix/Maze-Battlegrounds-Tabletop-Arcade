<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Battleground: Tabletop Arcade</title>
    <style>
        body {
            background-color: #050505;
            color: #eee;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-image: radial-gradient(circle at center, #111 0%, #000 100%);
            overflow: hidden; 
            user-select: none;
            outline: none;
        }

        .arcade-header {
            width: 960px; 
            background: #0a0a0a;
            border: 4px solid #333;
            border-radius: 4px;
            margin-bottom: 20px;
            padding: 15px;
            box-shadow: 0 0 25px rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            border-bottom: 2px solid #333;
            padding-bottom: 8px;
            margin-bottom: 5px;
        }

        .game-title {
            margin: 0; font-size: 2.0em; color: #fff; letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(255,255,255,0.4); font-weight: 900;
            text-transform: uppercase;
            font-style: italic;
        }
        
        .round-info { 
            color: #f0c040; font-size: 1.1em; font-weight: bold; 
            text-shadow: 0 0 5px rgba(240, 192, 64, 0.5);
            letter-spacing: 1px;
        }

        .instructions-grid {
            display: grid;
            grid-template-columns: 1fr 1.8fr 1fr;
            gap: 10px;
            font-size: 0.85em;
        }

        .player-card { 
            text-align: center; 
            background: rgba(255,255,255,0.03); 
            padding: 8px; 
            border-radius: 4px;
        }
        
        .p1-title { color: #00ffff; font-weight: bold; font-size: 1.2em; margin-bottom: 8px; border-bottom: 2px solid #00ffff; display: inline-block; padding: 0 10px;}
        .p2-title { color: #ff00ff; font-weight: bold; font-size: 1.2em; margin-bottom: 8px; border-bottom: 2px solid #ff00ff; display: inline-block; padding: 0 10px;}
        
        .controls-list { line-height: 1.8em; color: #aaa; text-align: left; padding-left: 20px;}
        .key { background: #333; color: #fff; padding: 2px 6px; border-radius: 4px; border: 1px solid #555; font-weight: bold; font-size: 0.9em;}
        .label { float: right; margin-right: 20px; font-size: 0.8em; color: #777; }

        .mechanics-card {
            text-align: left;
            padding: 0 15px;
            color: #ccc;
            border-left: 2px solid #222;
            border-right: 2px solid #222;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .mech-row { margin-bottom: 6px; display: flex; align-items: center; }
        .mech-icon { width: 20px; display: inline-block; text-align: center; margin-right: 10px; font-weight: bold;}
        .highlight-green { color: #55ff55; font-weight: bold; }
        .highlight-red { color: #ff5555; font-weight: bold; }
        .highlight-yellow { color: #ffff55; font-weight: bold; }
        .highlight-blue { color: #55ffff; font-weight: bold; }

        .console-case {
            background: #111; 
            padding: 10px; 
            border-radius: 2px;
            border: 1px solid #333;
            box-shadow: 0 20px 50px rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: fit-content;
        }

        .screen-bezel { 
            background: #000; 
            padding: 0; 
            box-shadow: inset 0 0 10px #000; 
            z-index: 10; 
            position: relative; 
        }

        canvas { 
            width: 960px;
            aspect-ratio: 2 / 1; 
            background-color: #000; 
            display: block; 
            image-rendering: pixelated; 
        }

        .info { position: absolute; bottom: 20px; text-align: center; color: #666; width: 100%; font-size: 0.8em; }
        
        .panel-id {
            position: absolute;
            bottom: -25px;
            right: 0;
            color: #333;
            font-size: 10px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body tabindex="0" onclick="this.focus()">

    <div class="arcade-header">
        <div class="header-top">
            <h1 class="game-title">MAZE BATTLEGROUND</h1>
            <div class="round-info">WIN CONDITION: 5 POINTS</div>
        </div>
        <div class="instructions-grid">
            <div class="player-card">
                <div class="p1-title">PLAYER 1 (LEFT SIDE)</div>
                <div class="controls-list">
                    <span class="key">WASD</span> <span class="label">MOVE</span><br>
                    <span class="key">F</span> <span class="label">BEAM</span><br>
                    <span class="key">G</span> <span class="label">BOOST</span><br>
                    <span class="key">H</span> <span class="label">MINE</span>
                </div>
            </div>
            <div class="mechanics-card">
                <div class="mech-row"><span class="mech-icon">✦</span> <span><span class="highlight-green">INFILTRATE:</span> Enter enemy spawn for <b>+1 Point</b>.</span></div>
                <div class="mech-row"><span class="mech-icon">⚠</span> <span><span class="highlight-red">ELIMINATE:</span> Shooting enemy resets the round.</span></div>
                <div class="mech-row"><span class="mech-icon">✖</span> <span><span class="highlight-blue">INTERCEPT:</span> Beams collide & cancel each other.</span></div>
                <div class="mech-row"><span class="mech-icon">✷</span> <span><span class="highlight-yellow">DESTRUCT:</span> Mines destroy walls (except borders).</span></div>
            </div>
            <div class="player-card">
                <div class="p2-title">PLAYER 2 (RIGHT SIDE)</div>
                <div class="controls-list">
                    <span class="key">ARROWS</span> <span class="label">MOVE</span><br>
                    <span class="key">K</span> <span class="label">BEAM</span><br>
                    <span class="key">L</span> <span class="label">BOOST</span><br>
                    <span class="key">M</span> <span class="label">MINE</span>
                </div>
            </div>
        </div>
    </div>

    <div class="console-case">
        <div class="screen-bezel">
            <canvas id="ledMatrix" width="1280" height="640"></canvas>
        </div>
        <div class="panel-id">P2.5-320x160-1/32S</div>
    </div>

    <div class="info">PRESS 'R' TO RESET ROUND / GAME</div>

    <script>
        const canvas = document.getElementById('ledMatrix');
        const ctx = canvas.getContext('2d');

        const LOGICAL_W = 128; 
        const LOGICAL_H = 64; 
        const PITCH = 10; 
        const LED_RADIUS = 3.5; 
        
        const HUD_WIDTH = 5; 
        const CELL_SIZE = 3; 
        const ROWS = 21; 
        const COLS = 39;
        const MAZE_PADDING_X = 0; const MAZE_OFFSET_X = HUD_WIDTH + MAZE_PADDING_X; 
        
        const BASE_SPEED = 0.3; const MAX_SPEED = 1.2;  
        const BOOST_DRAIN = 100 / (5 * 60); 
        const BOOST_COOLDOWN_FRAMES = 60; 

        const BEAM_LENGTH = 40; 
        const MAX_SCORE = 5;

        const MINE_ARM_TIME = 2000; 
        const MINE_COOLDOWN = 500; 
        const MAX_MINES = 3;
        const PARTICLE_COUNT = 40; 
        const TRAIL_LENGTH = 12; 
        
        let mines = []; 
        let particles = []; 

        const BITMAP_FONT = {
            'A': [0,1,0, 1,0,1, 1,1,1, 1,0,1, 1,0,1], 'B': [1,1,0, 1,0,1, 1,1,0, 1,0,1, 1,1,0],
            'C': [0,1,1, 1,0,0, 1,0,0, 1,0,0, 0,1,1], 'D': [1,1,0, 1,0,1, 1,0,1, 1,0,1, 1,1,0],
            'E': [1,1,1, 1,0,0, 1,1,0, 1,0,0, 1,1,1], 'F': [1,1,1, 1,0,0, 1,1,0, 1,0,0, 1,0,0],
            'G': [0,1,1, 1,0,0, 1,0,1, 1,0,1, 0,1,1], 'H': [1,0,1, 1,0,1, 1,1,1, 1,0,1, 1,0,1],
            'I': [1,1,1, 0,1,0, 0,1,0, 0,1,0, 1,1,1], 'J': [0,0,1, 0,0,1, 0,0,1, 1,0,1, 0,1,0],
            'K': [1,0,1, 1,0,1, 1,1,0, 1,0,1, 1,0,1], 'L': [1,0,0, 1,0,0, 1,0,0, 1,0,0, 1,1,1],
            'M': [1,0,1, 1,1,1, 1,0,1, 1,0,1, 1,0,1], 'N': [1,1,0, 1,0,1, 1,0,1, 1,0,1, 1,0,1],
            'O': [0,1,0, 1,0,1, 1,0,1, 1,0,1, 0,1,0], 'P': [1,1,0, 1,0,1, 1,1,0, 1,0,0, 1,0,0],
            'Q': [0,1,0, 1,0,1, 1,0,1, 0,1,0, 0,0,1], 'R': [1,1,0, 1,0,1, 1,1,0, 1,0,1, 1,0,1],
            'S': [0,1,1, 1,0,0, 0,1,0, 0,0,1, 1,1,0], 'T': [1,1,1, 0,1,0, 0,1,0, 0,1,0, 0,1,0],
            'U': [1,0,1, 1,0,1, 1,0,1, 1,0,1, 0,1,0], 'V': [1,0,1, 1,0,1, 1,0,1, 1,0,1, 0,1,0],
            'W': [1,0,1, 1,0,1, 1,0,1, 1,1,1, 1,0,1], 'X': [1,0,1, 1,0,1, 0,1,0, 1,0,1, 1,0,1],
            'Y': [1,0,1, 1,0,1, 0,1,0, 0,1,0, 0,1,0], 'Z': [1,1,1, 0,0,1, 0,1,0, 1,0,0, 1,1,1],
            '0': [0,1,0, 1,0,1, 1,0,1, 1,0,1, 0,1,0], '1': [0,1,0, 1,1,0, 0,1,0, 0,1,0, 1,1,1],
            '2': [1,1,0, 0,0,1, 0,1,0, 1,0,0, 1,1,1], '3': [1,1,0, 0,0,1, 0,1,0, 0,0,1, 1,1,0],
            '4': [1,0,1, 1,0,1, 1,1,1, 0,0,1, 0,0,1], '5': [1,1,1, 1,0,0, 1,1,0, 0,0,1, 1,1,0],
            '6': [0,1,1, 1,0,0, 1,1,0, 1,0,1, 0,1,0], '7': [1,1,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1],
            '8': [0,1,0, 1,0,1, 0,1,0, 1,0,1, 0,1,0], '9': [0,1,0, 1,0,1, 0,1,1, 0,0,1, 0,1,0],
            '!': [0,1,0, 0,1,0, 0,1,0, 0,0,0, 0,1,0], ' ': [0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0],
            "'": [0,1,0, 0,1,0, 0,0,0, 0,0,0, 0,0,0], '?': [1,1,0, 0,0,1, 0,1,0, 0,0,0, 0,1,0],
            '-': [0,0,0, 0,0,0, 1,1,1, 0,0,0, 0,0,0], '.': [0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,1,0],
            ',': [0,0,0, 0,0,0, 0,0,0, 0,1,0, 1,0,0]
        };

        const TAUNTS = [
            "YOUR MOTHER WAS A HAMSTER!",
            "I FART IN YOUR GENERAL DIRECTION!",
            "GO AWAY OR I SHALL TAUNT YOU AGAIN!",
            "YOU FIGHT LIKE A DAIRY FARMER!",
            "TIS BUT A SCRATCH!",
            "RUN AWAY! RUN AWAY!",
            "MY HOVERCRAFT IS FULL OF EELS!",
            "YOU EMPTY-HEADED ANIMAL!"
        ];

        let maze = []; let wallHue = 0; let isGameOver = false;
        let winMessage = ""; let tauntMessage = ""; let winColor = "#fff"; let scrollX = 0;
        
        const players = [
            { x: 0, y: 0, color: '#00ffff', size: 2.0, score: 0, beamPixels: [], beamIdx: 0, goalC: COLS-1, goalR: ROWS-1, lastMineTime: 0, minesLeft: 3, trail: [], boostEnergy: 100, boostCooldown: 0 }, 
            { x: 0, y: 0, color: '#ff00ff', size: 2.0, score: 0, beamPixels: [], beamIdx: 0, goalC: 0, goalR: 0, lastMineTime: 0, minesLeft: 3, trail: [], boostEnergy: 100, boostCooldown: 0 } 
        ];

        const DIGITS = {
            0: [1,1,1, 1,0,1, 1,0,1, 1,0,1, 1,1,1], 1: [0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0],
            2: [1,1,1, 0,0,1, 1,1,1, 1,0,0, 1,1,1], 3: [1,1,1, 0,0,1, 0,1,1, 0,0,1, 1,1,1],
            4: [1,0,1, 1,0,1, 1,1,1, 0,0,1, 0,0,1], 5: [1,1,1, 1,0,0, 1,1,1, 0,0,1, 1,1,1],
            6: [1,1,1, 1,0,0, 1,1,1, 1,0,1, 1,1,1], 7: [1,1,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1],
            8: [1,1,1, 1,0,1, 1,1,1, 1,0,1, 1,1,1], 9: [1,1,1, 1,0,1, 1,1,1, 0,0,1, 0,0,1]
        };

        const keys = {}; let gameTime = 0; let maxGameTime = 0; 

        class Cell { constructor(c, r) { this.c = c; this.r = r; this.walls = [true, true, true, true]; this.visited = false; this.parent = null; this.bfsVisited = false; } checkNeighbors() { let neighbors = []; let top = gridIndex(this.c, this.r - 1); let right = gridIndex(this.c + 1, this.r); let bottom = gridIndex(this.c, this.r + 1); let left = gridIndex(this.c - 1, this.r); if (top && !top.visited) neighbors.push(top); if (right && !right.visited) neighbors.push(right); if (bottom && !bottom.visited) neighbors.push(bottom); if (left && !left.visited) neighbors.push(left); return (neighbors.length > 0) ? neighbors[Math.floor(Math.random() * neighbors.length)] : undefined; } }
        function gridIndex(c, r) { if (c < 0 || r < 0 || c >= COLS || r >= ROWS) return undefined; return maze[c + r * COLS]; }
        function removeWalls(a, b) { let x = a.c - b.c; if (x === 1) { a.walls[3] = false; b.walls[1] = false; } if (x === -1) { a.walls[1] = false; b.walls[3] = false; } let y = a.r - b.r; if (y === 1) { a.walls[0] = false; b.walls[2] = false; } if (y === -1) { a.walls[2] = false; b.walls[0] = false; } }

        function initMaze() {
            maze = []; let stack = []; for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) maze.push(new Cell(c, r));
            let current = maze[0]; current.visited = true;
            while(true) { let next = current.checkNeighbors(); if (next) { next.visited = true; stack.push(current); removeWalls(current, next); current = next; } else if (stack.length > 0) current = stack.pop(); else break; }
            
            players[0].x = MAZE_OFFSET_X + 1; players[0].y = 1; 
            players[0].trail = []; 
            players[0].boostEnergy = 100;
            players[0].boostCooldown = 0;

            let endX = MAZE_OFFSET_X + ((COLS-1) * CELL_SIZE) + 1; let endY = ((ROWS-1) * CELL_SIZE) + 1;
            players[1].x = endX; players[1].y = endY; 
            players[1].trail = []; 
            players[1].boostEnergy = 100;
            players[1].boostCooldown = 0;

            mines = []; particles = [];
            players[0].minesLeft = MAX_MINES; players[1].minesLeft = MAX_MINES;
            players[0].beamPixels = []; players[1].beamPixels = [];
            updateAmmoUI(0); updateAmmoUI(1);
            calculateInitialTime();
        }

        function calculateInitialTime() {
            let start = gridIndex(0, 0); let end = gridIndex(COLS-1, ROWS-1);
            for(let i=0; i<maze.length; i++) { maze[i].bfsVisited = false; maze[i].parent = null; }
            let queue = [start]; start.bfsVisited = true; let pathLengthCells = 0; let found = false;
            while(queue.length > 0) {
                let curr = queue.shift(); if (curr === end) { found = true; break; }
                let neighbors = [ { cell: gridIndex(curr.c, curr.r - 1), wall: curr.walls[0] }, { cell: gridIndex(curr.c + 1, curr.r), wall: curr.walls[1] }, { cell: gridIndex(curr.c, curr.r + 1), wall: curr.walls[2] }, { cell: gridIndex(curr.c - 1, curr.r), wall: curr.walls[3] } ];
                for(let n of neighbors) { if (n.cell && !n.cell.bfsVisited && !n.wall) { n.cell.bfsVisited = true; n.cell.parent = curr; queue.push(n.cell); } }
            }
            if(found) { let temp = end; while(temp) { pathLengthCells++; temp = temp.parent; } }
            let distancePixels = pathLengthCells * CELL_SIZE; let estimatedSpeed = (BASE_SPEED + MAX_SPEED) / 2;
            gameTime = Math.floor((distancePixels / estimatedSpeed) * 6); maxGameTime = gameTime; 
        }

        function fireBeam(playerIndex) {
            let p = players[playerIndex]; if(p.beamIdx < p.beamPixels.length) return; 
            let mx = p.x - MAZE_OFFSET_X; let my = p.y;
            let startCol = Math.floor((mx + 1) / CELL_SIZE); let startRow = Math.floor((my + 1) / CELL_SIZE);
            let start = gridIndex(startCol, startRow); let end = gridIndex(p.goalC, p.goalR);
            if(!start || !end) return;
            for(let i=0; i<maze.length; i++) { maze[i].parent = null; maze[i].bfsVisited = false; }
            let queue = [start]; start.bfsVisited = true; let found = false;
            while(queue.length > 0) {
                let curr = queue.shift(); if (curr === end) { found = true; break; }
                let neighbors = [ { cell: gridIndex(curr.c, curr.r - 1), wall: curr.walls[0] }, { cell: gridIndex(curr.c + 1, curr.r), wall: curr.walls[1] }, { cell: gridIndex(curr.c, curr.r + 1), wall: curr.walls[2] }, { cell: gridIndex(curr.c - 1, curr.r), wall: curr.walls[3] } ];
                for(let n of neighbors) { if (n.cell && !n.cell.bfsVisited && !n.wall) { n.cell.bfsVisited = true; n.cell.parent = curr; queue.push(n.cell); } }
            }
            if (!found) return;
            let pathCells = []; let temp = end; while(temp) { pathCells.push(temp); temp = temp.parent; } pathCells.reverse();
            p.beamPixels = [];
            for(let i=0; i<pathCells.length - 1; i++) {
                let c1 = pathCells[i]; let c2 = pathCells[i+1];
                let x1 = MAZE_OFFSET_X + (c1.c * CELL_SIZE) + 1; let y1 = (c1.r * CELL_SIZE) + 1;
                let x2 = MAZE_OFFSET_X + (c2.c * CELL_SIZE) + 1; let y2 = (c2.r * CELL_SIZE) + 1;
                p.beamPixels.push({x: x1, y: y1});
                let dx = (x2 - x1) / 3; let dy = (y2 - y1) / 3;
                p.beamPixels.push({x: x1 + dx, y: y1 + dy}); p.beamPixels.push({x: x1 + (dx*2), y: y1 + (dy*2)});
            }
            let lastC = pathCells[pathCells.length-1]; p.beamPixels.push({ x: MAZE_OFFSET_X + (lastC.c * CELL_SIZE) + 1, y: (lastC.r * CELL_SIZE) + 1 });
            p.beamIdx = 0;
        }

        function dropMine(playerIndex) {
            let p = players[playerIndex];
            if (p.minesLeft <= 0) return;
            let now = Date.now();
            if (now - p.lastMineTime < MINE_COOLDOWN) return;
            p.lastMineTime = now;
            p.minesLeft--;
            updateAmmoUI(playerIndex);

            mines.push({
                x: Math.floor(p.x), y: Math.floor(p.y),
                droppedAt: now, active: false,
                visX: Math.floor(Math.random() * 2), visY: Math.floor(Math.random() * 2)
            });
        }

        function destroyWallAt(c, r) {
            if (c <= 0 || c >= COLS - 1 || r <= 0 || r >= ROWS - 1) return;
            let center = gridIndex(c, r);
            if (center) {
                center.walls = [false, false, false, false];
                let top = gridIndex(c, r - 1); if (top) top.walls[2] = false; 
                let right = gridIndex(c + 1, r); if (right) right.walls[3] = false; 
                let bottom = gridIndex(c, r + 1); if (bottom) bottom.walls[0] = false; 
                let left = gridIndex(c - 1, r); if (left) left.walls[1] = false; 
            }
        }

        function triggerExplosion(x, y) {
            let gridC = Math.floor((x - MAZE_OFFSET_X) / CELL_SIZE);
            let gridR = Math.floor(y / CELL_SIZE);
            destroyWallAt(gridC, gridR);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                particles.push({
                    x: x + 1, y: y + 1,
                    vx: (Math.random() - 0.5) * 2.5,
                    vy: (Math.random() - 0.5) * 2.5,
                    life: 1.0,
                    color: Math.random() > 0.5 ? '#ffff00' : '#ff4400'
                });
            }
        }

        function updateAmmoUI(playerIndex) {
            // Placeholder
        }

        function drawLED(lx, ly, color) {
            const centerX = (lx * PITCH) + (PITCH / 2); const centerY = (ly * PITCH) + (PITCH / 2);
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(centerX, centerY, LED_RADIUS, 0, Math.PI * 2); ctx.fill();
        }

        function drawText(str, x, y, color) {
            str = str.toUpperCase(); let cursorX = x;
            for(let i=0; i<str.length; i++) {
                let char = str[i]; let map = BITMAP_FONT[char];
                if(map) {
                    for(let p=0; p<15; p++) { if(map[p] === 1) { let col = p % 3; let row = Math.floor(p / 3); drawLED(cursorX + col, y + row, color); } }
                }
                cursorX += 4;
            }
        }

        function drawDigit(x, y, num, color, rotateDeg) {
            const map = DIGITS[num]; const w = 3; const h = 5;
            for(let i=0; i<15; i++) {
                if(map[i] === 1) {
                    let col = i % 3; let row = Math.floor(i / 3);
                    let dx, dy;
                    if (rotateDeg === -90) { 
                        // Base of number facing Left (X=0)
                        dx = row; dy = (w - 1 - col); 
                    } else if (rotateDeg === 90) { 
                        // Base of number facing Right (X=MAX)
                        dx = (h - 1 - row); dy = col; 
                    } else { 
                        dx = col; dy = row; 
                    }
                    drawLED(x + dx, y + dy, color);
                }
            }
        }

        function drawHUD(wallColor) {
            let p1 = players[0]; let p2 = players[1];
            let p1s = p1.score.toString().padStart(2, '0'); 
            let p2s = p2.score.toString().padStart(2, '0');
            
            let seconds = Math.ceil(gameTime / 60).toString().padStart(3, '0');
            
            let timeRatio = Math.max(0, Math.min(1, gameTime / maxGameTime));
            let clockHue = Math.floor(timeRatio * 180);
            let clockColor = `hsl(${clockHue}, 100%, 50%)`;

            // --- P1 (LEFT SIDE) ---
            // Rotation: 90 (Bottom faces Left)
            // Sequence: Score -> Time -> Boost/Mine
            
            // 1. Score (Y=0, Y=4)
            drawDigit(0, 0, parseInt(p1s[0]), '#00ffff', 90); 
            drawDigit(0, 4, parseInt(p1s[1]), '#00ffff', 90);

            // 2. Mines
            for(let i=0; i<3; i++) {
                let c = (i < p1.minesLeft) ? p1.color : '#222';
                drawLED(0 + (i*2), 8 , c); 
            }

            // 3. Boost Bar (Start Y=26, Fill Downwards)
            let b1MaxH = 42;
            let b1H = Math.floor((p1.boostEnergy / 100) * b1MaxH);
            let b1Hue = Math.floor((p1.boostEnergy / 100) * 120); 
            let b1Color = `hsl(${b1Hue}, 100%, 50%)`;
            for(let h=0; h<b1H; h++) {
                for(let w=0; w<5; w++) drawLED(w, 10 + h, b1Color);
            }

            // 4. Time (Y=11, 15, 19)
            drawDigit(0, 53, parseInt(seconds[0]), clockColor, 90);
            drawDigit(0, 57, parseInt(seconds[1]), clockColor, 90);
            drawDigit(0, 61, parseInt(seconds[2]), clockColor, 90);
            

            // --- P2 (RIGHT SIDE) ---
            // Rotation: -90 (Bottom faces Right)
            // Sequence: Score (Bottom Y=63) -> Time -> Boost/Mine
            
            let rx = 123; 

            // 1. Score (Y=61, Y=57) (Aligned to bottom)
            drawDigit(rx, 61, parseInt(p2s[0]), '#ff00ff', -90); 
            drawDigit(rx, 57, parseInt(p2s[1]), '#ff00ff', -90);

            // 2. Mines
            for(let i=0; i<3; i++) {
                let c = (i < p2.minesLeft) ? p2.color : '#222';
                drawLED(rx + 4 - (i*2) , 55 , c); 
            }

            // 3. Boost Bar (Start Y=37, Fill Upwards)
            let b2H = Math.floor((p2.boostEnergy / 100) * b1MaxH);
            let b2Hue = Math.floor((p2.boostEnergy / 100) * 120);
            let b2Color = `hsl(${b2Hue}, 100%, 50%)`;
            for(let h=0; h<b2H; h++) {
                for(let w=0; w<5; w++) drawLED(rx + w , 53 - h, b2Color); 
            }

            // 4. Time (Y=51, 47, 43)
            drawDigit(rx, 8, parseInt(seconds[0]), clockColor, -90);
            drawDigit(rx, 4, parseInt(seconds[1]), clockColor, -90);
            drawDigit(rx, 0, parseInt(seconds[2]), clockColor, -90);


        }

        function drawMazePixels(wallColor) {
            let goalColor = (Math.floor(Date.now() / 200) % 2 === 0) ? '#ffffff' : '#444444'; 
            let g1x = MAZE_OFFSET_X + (players[0].goalC * CELL_SIZE); let g1y = (players[0].goalR * CELL_SIZE);
            drawLED(g1x+1, g1y+1, goalColor); drawLED(g1x+2, g1y+1, goalColor); drawLED(g1x+1, g1y+2, goalColor); drawLED(g1x+2, g1y+2, goalColor);
            let g2x = MAZE_OFFSET_X + (players[1].goalC * CELL_SIZE); let g2y = (players[1].goalR * CELL_SIZE);
            drawLED(g2x+1, g2y+1, goalColor); drawLED(g2x+2, g2y+1, goalColor); drawLED(g2x+1, g2y+2, goalColor); drawLED(g2x+2, g2y+2, goalColor);

            mines.forEach(m => {
                let flash = Math.floor(Date.now() / 100) % 2 === 0;
                let color = m.active ? (flash ? '#ff0000' : '#880000') : '#444444';
                drawLED(m.x + m.visX, m.y + m.visY, color);
            });

            players.forEach(p => {
                if(p.beamIdx < p.beamPixels.length + BEAM_LENGTH) { 
                    for(let k=0; k<BEAM_LENGTH; k++) {
                        let i = Math.floor(p.beamIdx) - k;
                        if(i >= 0 && i < p.beamPixels.length) {
                            let point = p.beamPixels[i]; ctx.globalAlpha = 1.0 - (k/BEAM_LENGTH); drawLED(point.x, point.y, p.color); ctx.globalAlpha = 1.0;
                        }
                    }
                }
            });

            for (let i = 0; i < maze.length; i++) {
                let cell = maze[i]; let x = (cell.c * CELL_SIZE) + MAZE_OFFSET_X; let y = cell.r * CELL_SIZE;
                drawLED(x, y, wallColor); 
                if (cell.walls[0]) { drawLED(x+1, y, wallColor); drawLED(x+2, y, wallColor); } 
                if (cell.walls[3]) { drawLED(x, y+1, wallColor); drawLED(x, y+2, wallColor); } 
                if (cell.c === COLS - 1) { drawLED(x+3, y, wallColor); if (cell.walls[1]) { drawLED(x+3, y+1, wallColor); drawLED(x+3, y+2, wallColor); } }
                if (cell.r === ROWS - 1) { drawLED(x, y+3, wallColor); if (cell.walls[2]) { drawLED(x+1, y+3, wallColor); drawLED(x+2, y+3, wallColor); } }
                if (cell.c === COLS - 1 && cell.r === ROWS - 1) drawLED(x+3, y+3, wallColor);
            }

            particles.forEach((p, idx) => {
                drawLED(p.x, p.y, p.color);
                p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                if(p.life <= 0) particles.splice(idx, 1);
            });

            players.forEach(p => {
                let speedFactor = (p.boostEnergy > 0 && (p.currentSpeed > BASE_SPEED)) ? 1.0 : 0.0;
                if (speedFactor > 0) {
                    p.trail.forEach((pos, index) => {
                        let fade = (index / p.trail.length) * 0.5; 
                        ctx.globalAlpha = fade;
                        for(let py=0; py<p.size; py++) for(let px=0; px<p.size; px++) 
                            drawLED(Math.floor(pos.x + px), Math.floor(pos.y + py), p.color);
                        ctx.globalAlpha = 1.0;
                    });
                }
            });
        }

        function isWall(pixelX, pixelY) {
            if (pixelX < MAZE_OFFSET_X || pixelX >= LOGICAL_W - HUD_WIDTH) return true; 
            if (pixelY < 0 || pixelY >= LOGICAL_H) return true;
            let mx = pixelX - MAZE_OFFSET_X; let my = pixelY;
            let col = Math.floor(mx / CELL_SIZE); let row = Math.floor(my / CELL_SIZE);
            let cell = gridIndex(col, row);
            if (!cell) return true;
            let lx = Math.floor(mx) % CELL_SIZE; let ly = Math.floor(my) % CELL_SIZE; 
            if (lx === 0 && ly === 0) return true;
            if (ly === 0 && cell.walls[0]) return true;
            if (lx === 0 && cell.walls[3]) return true;
            return false;
        }

        function checkPlayerCollision(p, dx, dy) {
            let nextX = p.x + dx; let nextY = p.y + dy;
            let padding = 0.6; let hitboxSize = 0.8; 
            let x1 = nextX + padding; let y1 = nextY + padding;
            let x2 = x1 + hitboxSize; let y2 = y1 + hitboxSize;
            if (isWall(x1, y1) || isWall(x2, y1) || isWall(x1, y2) || isWall(x2, y2)) return true;
            return false;
        }

        function performMove(p, dx, dy) {
            let dist = Math.hypot(dx, dy);
            let stepSize = 0.5;
            let stepCount = Math.ceil(dist / stepSize);
            
            let sx = dx / stepCount;
            let sy = dy / stepCount;
            
            for(let i=0; i<stepCount; i++) {
                if (sx !== 0) {
                    if (!checkPlayerCollision(p, sx, 0)) {
                        p.x += sx;
                    } 
                }
                if (sy !== 0) {
                    if (!checkPlayerCollision(p, 0, sy)) {
                        p.y += sy;
                    }
                }
            }
        }

        function checkGoal(p) {
            let gx = MAZE_OFFSET_X + (p.goalC * CELL_SIZE) + 1; let gy = (p.goalR * CELL_SIZE) + 1;
            if (Math.abs(p.x - gx) < 1.0 && Math.abs(p.y - gy) < 1.0) return true; return false;
        }

        function triggerWin(playerIndex) {
            isGameOver = true;
            winColor = players[playerIndex].color;
            winMessage = `PLAYER ${playerIndex + 1} WINS!`;
            tauntMessage = TAUNTS[Math.floor(Math.random() * TAUNTS.length)];
            scrollX = LOGICAL_W + 5; 
        }

        function resetGame() {
            players[0].score = 0; players[1].score = 0; isGameOver = false; initMaze();
        }

        function setKey(k, state) {
            keys[k.toLowerCase()] = state;
        }

        function update() {
            if (isGameOver) { scrollX -= 0.5; if (scrollX < - (tauntMessage.length * 4.5)) scrollX = LOGICAL_W; return; }
            if(gameTime <= 0) { initMaze(); return; }
            gameTime -= 1; wallHue = (wallHue + 0.5) % 360; 
            
            let now = Date.now();
            for(let i=0; i<mines.length; i++) {
                let m = mines[i];
                if (!m.active && now - m.droppedAt > MINE_ARM_TIME) m.active = true;
            }

            let p1 = players[0]; let p2 = players[1];
            let b1Idx = Math.floor(p1.beamIdx); let b2Idx = Math.floor(p2.beamIdx);
            
            if (p1.beamPixels.length > 0 && p2.beamPixels.length > 0 && 
                b1Idx < p1.beamPixels.length && b2Idx < p2.beamPixels.length) {
                
                let h1 = p1.beamPixels[b1Idx];
                let h2 = p2.beamPixels[b2Idx];
                let dist = Math.abs(h1.x - h2.x) + Math.abs(h1.y - h2.y);
                
                if (dist < 4) { 
                    triggerExplosion((h1.x+h2.x)/2, (h1.y+h2.y)/2);
                    p1.beamPixels = []; p1.beamIdx = 9999;
                    p2.beamPixels = []; p2.beamIdx = 9999;
                }
            }

            players.forEach((p, idx) => { 
                p.trail.push({x: p.x, y: p.y});
                if(p.trail.length > TRAIL_LENGTH) p.trail.shift();

                if(p.beamIdx < p.beamPixels.length + BEAM_LENGTH) p.beamIdx += 0.8; 
                let opponent = players[(idx + 1) % 2];
                
                let tipIndex = Math.floor(opponent.beamIdx);
                if (tipIndex >= 0 && tipIndex < opponent.beamPixels.length) {
                    let tip = opponent.beamPixels[tipIndex];
                    if (Math.abs(p.x - tip.x) < 1.5 && Math.abs(p.y - tip.y) < 1.5) { p.score = Math.max(0, p.score - 1); initMaze(); return; }
                }

                for(let i=mines.length-1; i>=0; i--) {
                    let m = mines[i];
                    let bIdx = Math.floor(p.beamIdx);
                    if(bIdx >=0 && bIdx < p.beamPixels.length) {
                        let bp = p.beamPixels[bIdx];
                        if (bp.x >= m.x - 1 && bp.x <= m.x+3 && bp.y >= m.y - 1 && bp.y <= m.y+3) {
                            triggerExplosion(m.x, m.y);
                            mines.splice(i, 1); 
                            p.beamPixels = [];
                            p.beamIdx = 9999;
                            continue;
                        }
                    }
                    if(m.active) {
                        if (p.x + p.size > m.x && p.x < m.x + 2 && p.y + p.size > m.y && p.y < m.y + 2) {
                            triggerExplosion(m.x, m.y);
                            p.score = Math.max(0, p.score - 1); initMaze(); return;
                        }
                    }
                }
            });

            // --- PLAYER 1 INPUT ---
            let s1 = BASE_SPEED;
            if (p1.boostCooldown > 0) {
                p1.boostCooldown--;
                p1.boostEnergy = Math.min(100, p1.boostEnergy + BOOST_DRAIN);
                s1 = BASE_SPEED;
            } else {
                if (keys['g']) {
                    if (p1.boostEnergy > 0) {
                        p1.boostEnergy -= BOOST_DRAIN;
                        s1 = MAX_SPEED;
                        if (p1.boostEnergy <= 0) {
                            p1.boostEnergy = 0;
                            s1 = BASE_SPEED;
                        }
                    } else {
                        s1 = BASE_SPEED;
                    }
                } else {
                    if (p1.boostEnergy <= 0) {
                        p1.boostCooldown = BOOST_COOLDOWN_FRAMES;
                    } else {
                        p1.boostEnergy = Math.min(100, p1.boostEnergy + BOOST_DRAIN);
                    }
                }
            }
            p1.currentSpeed = s1;

            if (keys['w']) performMove(p1, 0, -s1);
            if (keys['s']) performMove(p1, 0, s1);
            if (keys['a']) performMove(p1, -s1, 0);
            if (keys['d']) performMove(p1, s1, 0);
            
            if (keys['h']) dropMine(0);
            if (keys['f']) fireBeam(0);

            // --- PLAYER 2 INPUT ---
            let s2 = BASE_SPEED;
            if (p2.boostCooldown > 0) {
                p2.boostCooldown--;
                p2.boostEnergy = Math.min(100, p2.boostEnergy + BOOST_DRAIN);
                s2 = BASE_SPEED;
            } else {
                if (keys['l']) {
                    if (p2.boostEnergy > 0) {
                        p2.boostEnergy -= BOOST_DRAIN;
                        s2 = MAX_SPEED;
                        if (p2.boostEnergy <= 0) {
                            p2.boostEnergy = 0;
                            s2 = BASE_SPEED;
                        }
                    } else {
                        s2 = BASE_SPEED;
                    }
                } else {
                    if (p2.boostEnergy <= 0) {
                        p2.boostCooldown = BOOST_COOLDOWN_FRAMES;
                    } else {
                        p2.boostEnergy = Math.min(100, p2.boostEnergy + BOOST_DRAIN);
                    }
                }
            }
            p2.currentSpeed = s2;

            if (keys['arrowup']) performMove(p2, 0, -s2);
            if (keys['arrowdown']) performMove(p2, 0, s2);
            if (keys['arrowleft']) performMove(p2, -s2, 0);
            if (keys['arrowright']) performMove(p2, s2, 0);
            
            if (keys['m']) dropMine(1);
            if (keys['k']) fireBeam(1);

            if (checkGoal(players[0])) { players[0].score++; if(players[0].score >= MAX_SCORE) triggerWin(0); else initMaze(); }
            else if (checkGoal(players[1])) { players[1].score++; if(players[1].score >= MAX_SCORE) triggerWin(1); else initMaze(); }
        }

        function loop() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            for(let y=0; y<LOGICAL_H; y++) for(let x=0; x<LOGICAL_W; x++) drawLED(x, y, '#222');
            
            if(isGameOver) {
                let flash = Math.floor(Date.now() / 200) % 2 === 0;
                if(flash) drawText(winMessage, 10, 15, winColor);
                drawText(tauntMessage, scrollX, 35, "#ff5555");
                drawText("PRESS 'R'", 40, 52, "#888");
            } else {
                let dynamicColor = `hsl(${wallHue}, 100%, 50%)`;
                drawMazePixels(dynamicColor); drawHUD(dynamicColor); 
                update();
                players.forEach(p => {
                    for(let py=0; py<p.size; py++) for(let px=0; px<p.size; px++) 
                        drawLED(Math.floor(p.x + px), Math.floor(p.y + py), p.color);
                });
            }
            requestAnimationFrame(loop);
        }
        
        window.addEventListener('keydown', (e) => { 
            let k = e.key.toLowerCase(); 
            keys[k] = true; 
            if(k === 'r') {
                if(isGameOver) resetGame(); else initMaze(); 
            }
        });
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        window.addEventListener('blur', () => { for(let k in keys) keys[k] = false; });
        
        initMaze(); loop();
        window.focus();
    </script>
</body>
</html>