<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Battleground: Pixel Perfect</title>
    <script src="libs/nipplejs.min.js"></script>
    <style>
        /* =========================================
           1. GLOBAL STYLES
           ========================================= */
        body {
            background-color: #050505;
            background-image: radial-gradient(circle at center, #111 0%, #000 100%);
            color: #eee;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
            outline: none;
        }

        /* =========================================
           MOBILE / RESPONSIVE STYLES (FIXED)
           ========================================= */
        #mobile-rules-btn,
        #mobile-rules-modal,
        #mobile-config,
        #mobile-controls {
            display: none;
        }

        @media (max-width: 1024px) {

            body {
                justify-content: flex-start;
                align-items: center;
                padding-top: 0;
                background: #000;
                height: 100vh;
                overflow: hidden;
            }

            .arcade-header {
                display: none !important;
            }

            .info,
            .panel-id {
                display: none !important;
            }

            #mobile-rules-btn {
                display: flex;
                position: absolute;
                top: 10px;
                left: 10px;
                width: 50px;
                height: 40px;
                background: rgba(255, 255, 255, 0.1);
                border: 2px solid rgba(255, 255, 255, 0.4);
                border-radius: 10px;
                color: #fff;
                justify-content: center;
                align-items: center;
                font-weight: bold;
                font-size: 20px;
                z-index: 20000;
                backdrop-filter: blur(4px);
                cursor: pointer;
            }

            #mobile-rules-modal {
                display: none;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                z-index: 20001;
                justify-content: center;
                align-items: center;
                backdrop-filter: blur(5px);
            }

            .modal-content {
                background: #111;
                border: 2px solid #444;
                padding: 20px;
                border-radius: 8px;
                width: 80%;
                max-width: 400px;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.9);
                text-align: left;
            }

            .m-rule {
                margin: 8px 0;
                font-size: 0.9em;
                border-bottom: 1px dashed #222;
                padding-bottom: 4px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .m-rule .icon {
                font-size: 1.2em;
                width: 20px;
                text-align: center;
            }

            .close-btn {
                margin-top: 15px;
                background: #333;
                color: #fff;
                text-align: center;
                padding: 10px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                border: 1px solid #555;
            }

            .close-btn:active {
                background: #555;
            }

            .console-case {
                margin-top: 5px;
                width: 98vw;
                max-width: 100%;
                padding: 0;
                border: none;
                background: transparent;
                box-shadow: none;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
                max-height: 75vh;
                object-fit: contain;
            }

            .touch-area.config {
                pointer-events: auto;
                display: grid;
                gap: 7px;
                align-content: center;
                grid-template-columns: 40px;
                grid-template-rows: 40px 40px 40px;
                margin-left: 5px;
            }

            #mobile-config {
                display: flex;
                position: absolute;
                top: 10px;
                left: 10px;
                width: 100%;
                justify-content: space-between;
                padding: 0;
                box-sizing: border-box;
                z-index: 9999;
                pointer-events: none;
            }

            .btn[data-key="KeySelect"] {
                border-radius: 10px;
                width: 80px;
                height: 40px;
                grid-column: 1;
                grid-row: 3;
            }

            .btn[data-key="KeyStart"] {
                border-radius: 10px;
                width: 80px;
                height: 40px;
                grid-column: 1;
                grid-row: 2;
            }

            .btnInfo {
                width: 80px;
                height: 40px;
                background: rgba(255, 255, 255, 0.1);
                border: 2px solid rgba(255, 255, 255, 0.4);
                border-radius: 30%;
                color: #fff;
                display: flex;
                justify-content: center;
                align-items: center;
                font-weight: bold;
                font-size: 11px;
                border-radius: 10px;
                grid-column: 1;
                grid-row: 1;
            }

            .btnInfo:active {
                background: rgba(255, 0, 0, 0.5);
            }

            .touch-area.actions {
                pointer-events: auto;
                display: grid;
                gap: 7px;
                align-content: center;
                grid-template-columns: 55px 55px;
                grid-template-rows: 55px 55px 55px;
                margin-right: 10px;
            }

            #mobile-controls {
                display: flex;
                position: absolute;
                bottom: 10px;
                left: 0;
                width: 100%;
                justify-content: space-between;
                padding: 0;
                box-sizing: border-box;
                z-index: 9999;
                pointer-events: none;
            }

            #joystick-zone {
                width: 17%;
                /* height: 100%; */
                pointer-events: auto;
                position: relative;
            }

            .touch-area.actions {
                pointer-events: auto;
                display: grid;
                gap: 7px;
                align-content: center;
                grid-template-columns: 55px 55px;
                grid-template-rows: 55px 55px 55px;
                margin-right: 10px;
            }

            .btn {
                width: 55px;
                height: 55px;
                background: rgba(255, 255, 255, 0.1);
                border: 2px solid rgba(255, 255, 255, 0.4);
                border-radius: 30%;
                color: #fff;
                display: flex;
                justify-content: center;
                align-items: center;
                font-weight: bold;
                font-size: 11px;
                user-select: none;
                backdrop-filter: blur(2px);
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            }

            .btn:active {
                background: rgba(255, 255, 255, 0.3);
                transform: scale(0.95);
            }

            .btn[data-key="KeyG"] {
                grid-column: 1;
                grid-row: 3;
            }

            .btn[data-key="KeyR"] {
                grid-column: 2;
                grid-row: 3;
            }

            .btn[data-key="KeyF"] {
                border-radius: 10px;
                width: 115px;
                grid-column-start: 1;
                grid-column-end: 2;
                grid-row: 2;
            }

            .btn[data-key="KeyE"] {
                grid-column: 1;
                grid-row: 1;
            }

            .btn[data-key="Space"] {
                grid-column: 2;
                grid-row: 1;
                /* border-width: 3px; */
                background: rgba(255, 0, 0, 0.3);
            }
        }

        @media (max-width: 900px) and (orientation: portrait) {
            body::before {
                content: "PLEASE ROTATE YOUR DEVICE â†»";
                position: absolute;
                top: 40%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: yellow;
                font-size: 20px;
                background: rgba(0, 0, 0, 0.8);
                padding: 10px;
                z-index: 10000;
                pointer-events: none;
            }
        }

        /* =========================================
           2. UI COMPONENTS
           ========================================= */
        .arcade-header {
            width: 960px;
            background: #0b0b0b;
            border: 2px solid #333;
            border-bottom: 4px solid #444;
            border-radius: 6px;
            margin-bottom: 10px;
            padding: 8px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(90deg, #111 0%, #1a1a1a 50%, #111 100%);
            padding: 4px 12px;
            border: 1px solid #333;
            border-radius: 4px;
        }

        .game-title {
            font-size: 1.3em;
            color: #fff;
            letter-spacing: 3px;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            font-style: italic;
            text-transform: uppercase;
        }

        .round-info {
            font-size: 0.8em;
            color: #ffd700;
            font-weight: bold;
            letter-spacing: 1px;
            background: rgba(255, 215, 0, 0.1);
            padding: 2px 6px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 3px;
        }

        /* --- DASHBOARD --- */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1.3fr 1fr;
            gap: 8px;
            height: 110px;
        }

        .panel {
            background: rgba(20, 20, 20, 0.6);
            border-radius: 4px;
            padding: 5px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .p1-panel {
            border: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.05);
        }

        .p2-panel {
            border: 1px solid rgba(255, 0, 255, 0.2);
            box-shadow: inset 0 0 15px rgba(255, 0, 255, 0.05);
        }

        .rules-panel {
            border: 1px solid #333;
            background: #080808;
        }

        .panel-header {
            font-size: 0.75em;
            font-weight: 900;
            text-align: center;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-shadow: 0 0 5px currentColor;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
        }

        .c-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.65em;
            color: #aaa;
            background: rgba(255, 255, 255, 0.03);
            padding: 1px 4px;
            border-radius: 2px;
        }

        .key-cap {
            background: #222;
            color: #fff;
            padding: 0px 5px;
            border-radius: 2px;
            border-bottom: 1px solid #444;
            border-top: 1px solid #333;
            border-left: 1px solid #333;
            border-right: 1px solid #333;
            font-family: monospace;
            font-weight: bold;
            font-size: 1em;
            min-width: 14px;
            text-align: center;
            display: inline-block;
            line-height: 1.2;
        }

        .action-name {
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .act-atk {
            color: #ff5555;
        }

        .act-def {
            color: #55ffff;
        }

        .act-mov {
            color: #55ff55;
        }

        /* --- LEGEND --- */
        .legend-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px 8px;
            font-size: 0.65em;
            color: #ccc;
            height: 100%;
            align-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            border-bottom: 1px dashed #222;
            padding-bottom: 1px;
        }

        .l-icon {
            width: 10px;
            text-align: center;
            font-size: 1.1em;
        }

        .l-text {
            display: flex;
            flex-direction: column;
            line-height: 1.0;
        }

        .l-title {
            font-weight: bold;
            font-size: 0.95em;
        }

        .l-desc {
            font-size: 0.85em;
            opacity: 0.7;
        }

        .hl-red {
            color: #ff5555;
        }

        .hl-blue {
            color: #55ffff;
        }

        .hl-gold {
            color: #ffd700;
        }

        .hl-purple {
            color: #ff55ff;
        }

        /* --- CANVAS --- */
        .console-case {
            background: #111;
            padding: 8px;
            border-radius: 2px;
            border: 1px solid #333;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: fit-content;
        }

        .screen-bezel {
            background: #000;
            padding: 0;
            box-shadow: inset 0 0 10px #000;
            z-index: 10;
            position: relative;
        }

        canvas {
            width: 960px;
            aspect-ratio: 2 / 1;
            background-color: #000;
            display: block;
            image-rendering: pixelated;
        }

        .info {
            position: absolute;
            bottom: 5px;
            text-align: center;
            color: #555;
            width: 100%;
            font-size: 0.7em;
        }

        .panel-id {
            position: absolute;
            bottom: -20px;
            right: 0;
            color: #333;
            font-size: 9px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>

<body tabindex="0" onclick="this.focus()">

    <div class="arcade-header">
        <div class="header-bar">
            <div class="game-title">MAZE BATTLEGROUND <span
                    style="font-size:0.5em; opacity:0.5; vertical-align: middle;">MAYHEM</span></div>
            <div class="round-info" id="statusText">SELECT MODE</div>
        </div>

        <div class="dashboard">
            <div class="panel p1-panel">
                <div class="panel-header" style="color: #00ffff;">PLAYER 1</div>
                <div class="control-group">
                    <div class="c-row">
                        <span class="action-name act-mov">MOVE</span>
                        <div><span class="key-cap">W</span><span class="key-cap">A</span><span
                                class="key-cap">S</span><span class="key-cap">D</span></div>
                    </div>
                    <div class="c-row">
                        <span class="action-name act-atk">MINE/BOOM</span>
                        <div><span class="key-cap">E</span>+<span class="key-cap">SPC</span></div>
                    </div>
                    <div class="c-row">
                        <span class="action-name act-def">SHIELD</span><span class="key-cap">R</span>
                    </div>
                    <div class="c-row">
                        <span class="action-name act-def">BEAM</span><span class="key-cap">F</span>
                    </div>
                    <div class="c-row">
                        <span class="action-name act-mov">BOOST</span><span class="key-cap">G</span>
                    </div>
                </div>
            </div>

            <div class="panel rules-panel">
                <div class="panel-header" style="color: #aaa; font-size: 0.75em; letter-spacing: 4px;">SYSTEM MECHANICS
                </div>
                <div class="legend-grid">
                    <div class="legend-item">
                        <span class="l-icon">â˜ </span>
                        <div class="l-text"><span class="l-title hl-red">MINES</span><span class="l-desc">Lethal. 1
                                Pt.</span></div>
                    </div>
                    <div class="legend-item">
                        <span class="l-icon">ðŸ›¡</span>
                        <div class="l-text"><span class="l-title hl-blue">SHIELD</span><span class="l-desc">Blocks
                                All.</span></div>
                    </div>
                    <div class="legend-item">
                        <span class="l-icon">âš¡</span>
                        <div class="l-text"><span class="l-title hl-gold">TAP BEAM</span><span class="l-desc">Stuns
                                Enemy.</span></div>
                    </div>
                    <div class="legend-item">
                        <span class="l-icon">ðŸ’¥</span>
                        <div class="l-text"><span class="l-title hl-gold">HOLD BEAM</span><span class="l-desc">Break
                                Wall/Kill.</span></div>
                    </div>
                    <div class="legend-item">
                        <span class="l-icon">ðŸŒ€</span>
                        <div class="l-text"><span class="l-title hl-purple">PORTAL</span><span
                                class="l-desc">Teleport.</span></div>
                    </div>
                    <div class="legend-item">
                        <span class="l-icon">âš </span>
                        <div class="l-text"><span class="l-title hl-red">GLITCH</span><span class="l-desc">Invert
                                Ctrl.</span></div>
                    </div>
                </div>
            </div>

            <div class="panel p2-panel">
                <div class="panel-header" style="color: #ff00ff;">PLAYER 2 / CPU</div>
                <div class="control-group">
                    <div class="c-row">
                        <div><span class="key-cap">^</span><span class="key-cap">&lt;</span><span
                                class="key-cap">v</span><span class="key-cap">&gt;</span></div><span
                            class="action-name act-mov">MOVE</span>
                    </div>
                    <div class="c-row">
                        <div><span class="key-cap">O</span>+<span class="key-cap">ENT</span></div><span
                            class="action-name act-atk">MINE/BOOM</span>
                    </div>
                    <div class="c-row">
                        <span class="key-cap">I</span><span class="action-name act-def">SHIELD</span>
                    </div>
                    <div class="c-row">
                        <span class="key-cap">K</span><span class="action-name act-def">BEAM</span>
                    </div>
                    <div class="c-row">
                        <span class="key-cap">L</span><span class="action-name act-mov">BOOST</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="console-case">
        <div class="screen-bezel">
            <canvas id="ledMatrix" width="1280" height="640"></canvas>
        </div>
        <div class="panel-id">P2.5 RGB LED panel 128px x 64px - 320mm x 160mm</div>
    </div>
    <div class="info">MENU: '1'/'2' | GAME: 'R' NEXT ROUND/RESET | 'ESC' MENU |
        <span style="color: #ffaa00;">âš  ANTI-GHOSTING KEYBOARD REQUIRED</span>
    </div>

    <div id="mobile-rules-modal">
        <div class="modal-content">
            <h3 style="border-bottom: 1px solid #333; padding-bottom: 5px;">SYSTEM MECHANICS</h3>

            <div class="m-rule"><span class="icon">â˜ </span> <span style="color:#ff5555">MINES</span>: Lethal (1 Pt)
            </div>
            <div class="m-rule"><span class="icon">ðŸ›¡</span> <span style="color:#55ffff">SHIELD</span>: Blocks All</div>
            <div class="m-rule"><span class="icon">âš¡</span> <span style="color:#ffd700">TAP BEAM</span>: Stuns Enemy
            </div>
            <div class="m-rule"><span class="icon">ðŸ’¥</span> <span style="color:#ffd700">HOLD BEAM</span>: Break/Kill
            </div>
            <div class="m-rule"><span class="icon">ðŸŒ€</span> <span style="color:#ff55ff">PORTAL</span>: Teleport</div>
            <div class="m-rule"><span class="icon">âš </span> <span style="color:#ff5555">GLITCH</span>: Invert Controls
            </div>

            <div class="close-btn" onclick="toggleRules()">CLOSE</div>
        </div>
    </div>
    <div id="mobile-config">
        <div class="touch-area config">
            <div class="btnInfo" style="border-color: #00b7ff; color: #00b7ff;" onclick="toggleRules()">?</div>
            <div class="btn" style="border-color: #00ff00; color: #00ff00;" data-key="KeyStart">Start</div>
            <!-- <div class="btn" style="border-color: #ffd700; color: #ffd700;" data-key="KeySelect">Select</div> -->
        </div>
    </div>
    <div id="mobile-controls">
        <div id="joystick-zone"></div>
        <div class="touch-area actions">
            <div class="btn" style="border-color: #55ffff; color: #55ffff;" data-key="KeyR">SHLD</div>
            <div class="btn" style="border-color: #00ff00; color: #00ff00;" data-key="KeyG">BOOST</div>
            <div class="btn" style="border-color: #ffd700; color: #ffd700;" data-key="KeyF">BEAM</div>
            <div class="btn" style="border-color: #ff5555; color: #ff5555;" data-key="Space">BOOM</div>
            <div class="btn" style="border-color: #ff55ff; color: #ff55ff;" data-key="KeyE">MINE</div>
        </div>
    </div>
    <script>
        /** * ==========================================
         * 1. CONFIGURATION & CONSTANTS
         * ==========================================
         */
        const CONFIG = {
            LOGICAL_W: 128,
            LOGICAL_H: 64,
            PITCH: 10,
            LED_RADIUS: 3.5,
            HUD_WIDTH: 8,
            CELL_SIZE: 3,
            ROWS: 21,
            COLS: 37,
            MAZE_OFFSET_X: 8,
            BASE_SPEED: 0.3,
            MAX_SPEED: 1.2,
            MAX_SCORE: 5,
            MAX_MINES: 4,
            BOOST_DRAIN: 100 / (5 * 60),
            SHIELD_DRAIN: (100 / (5 * 60)) * 1.5,
            BOOST_REGEN: (100 / (5 * 60)) * 0.3,
            BOOST_COOLDOWN_FRAMES: 60,
            STUN_DURATION: 360,
            GLITCH_DURATION: 180,
            GLITCH_CHANCE: 0.3,
            MINE_ARM_TIME: 2000,
            MINE_COOLDOWN: 500,
            AMMO_RESPAWN_DELAY: 300,
            BEAM_ENERGY_COST: 20,
            DETONATE_COST: 30,
            BEAM_LENGTH: 40,
            PARTICLE_COUNT: 40,
            TRAIL_LENGTH: 12,
            CHARGED_BEAM_COST: 80,
            CHARGE_TIME: 3000,
            CHARGE_PENALTY: 0.6,
            C_BEAM_SPEED: 0.6,
            C_BEAM_RANGE: 10,
            C_BEAM_LENGTH: 5,
            C_BEAM_WIDTH: 2,
            GAMEPAD_THRESH: 0.5
        };

        const CONTROLS_P1 = {
            select: 'KeySelect',
            start: 'KeyStart',
            up: 'KeyW',
            down: 'KeyS',
            left: 'KeyA',
            right: 'KeyD',
            shield: 'KeyR',
            beam: 'KeyF',
            mine: 'KeyE',
            boost: 'KeyG',
            boom: 'Space'
        };

        const CONTROLS_P2 = {
            select: 'KeySelect',
            start: 'KeyStart',
            up: 'ArrowUp',
            down: 'ArrowDown',
            left: 'ArrowLeft',
            right: 'ArrowRight',
            shield: 'KeyI',
            beam: 'KeyK',
            mine: 'KeyO',
            boost: 'KeyL',
            boom: 'Enter'
        };

        const TAUNTS = [
            "YOUR MOTHER WAS A HAMSTER!", "I FART IN YOUR GENERAL DIRECTION!",
            "GO AWAY OR I SHALL TAUNT YOU AGAIN!", "YOU FIGHT LIKE A DAIRY FARMER!",
            "TIS BUT A SCRATCH!", "RUN AWAY! RUN AWAY!",
            "MY HOVERCRAFT IS FULL OF EELS!", "YOU EMPTY-HEADED ANIMAL!"
        ];

        // Compact font arrays to save space
        const BITMAP_FONT = {
            'A': [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1],
            'B': [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0],
            'C': [0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1],
            'D': [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0],
            'E': [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1],
            'F': [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0],
            'G': [0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1],
            'H': [1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1],
            'I': [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1],
            'J': [0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0],
            'K': [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1],
            'L': [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1],
            'M': [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
            'N': [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
            'O': [0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0],
            'P': [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0],
            'Q': [0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1],
            'R': [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1],
            'S': [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0],
            'T': [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
            'U': [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0],
            'V': [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0],
            'W': [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
            'X': [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1],
            'Y': [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0],
            'Z': [1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1],
            '0': [0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0],
            '1': [0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1],
            '2': [1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1],
            '3': [1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0],
            '4': [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1],
            '5': [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0],
            '6': [0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0],
            '7': [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
            '8': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
            '9': [0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0],
            '!': [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
            ' ': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            '-': [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            '.': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
            ':': [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
        };

        const DIGIT_MAP = {
            0: [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1],
            1: [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
            2: [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1],
            3: [1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1],
            4: [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1],
            5: [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1],
            6: [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1],
            7: [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
            8: [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
            9: [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1]
        };

        const GRACE_FRAMES = 10;
        /** * ==========================================
         * 2. CLASSES
         * ==========================================
         */
        class SoundFX {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
                this.initialized = false;
            }

            init() {
                if (!this.initialized) {
                    this.ctx.resume().then(() => {
                        this.initialized = true;
                    });
                }
            }

            playTone(freq, type, duration, slideTo = null) {
                if (this.ctx.state === 'suspended') this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);

                if (slideTo) {
                    osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                }

                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playNoise(duration) {
                if (this.ctx.state === 'suspended') this.init();
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;

                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            }

            // --- PRESETS ---
            shoot() {
                this.playTone(800, 'square', 0.1, 100);
            } // "Pew"
            chargedShoot() {
                this.playTone(400, 'sawtooth', 0.4, 50);
            } // deep "Zap"
            charge() {
                this.playTone(200, 'sine', 0.1, 600);
            } // pitch up
            mineDrop() {
                this.playTone(600, 'sine', 0.1, 300);
            }
            explosion() {
                this.playNoise(0.4);
            } // "Kshhh"

            win() {
                [440, 554, 659, 880].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.2), i * 150));
            }

            powerup() {
                this.playTone(400, 'sine', 0.1);
                setTimeout(() => this.playTone(600, 'sine', 0.1), 100);
            }
            start() {
                this.playTone(440, 'triangle', 0.5, 880);
            }
            death() {
                const melody = [500, 400, 300, 200, 100, 50, 10];
                melody.forEach((freq, index) => {
                    setTimeout(() => {
                        this.playTone(freq, 'triangle', 0.1, freq - 50);
                    }, index * 120);
                });
            }
            roundOver() {
                this.playTone(880, 'square', 0.15); // Beep
                setTimeout(() => this.playTone(440, 'square', 0.4), 200); // Boop (Longer)
            }
            shield() {
                this.playTone(100, 'sine', 0.25, 800);
            }
            niaNiaNia() {
                const melody = [880, 784, 880, 784, 880, 784, 880];
                melody.forEach((freq, index) => {
                    setTimeout(() => {
                        this.playTone(freq, 'triangle', 0.1, freq - 50);
                    }, index * 120);
                });
            }
        }

        class Cell {
            constructor(c, r) {
                this.c = c;
                this.r = r;
                this.walls = [true, true, true, true];
                this.visited = false;
                this.parent = null;
                this.bfsVisited = false;
            }
        }

        class Player {
            constructor(id, color, controls) {
                this.id = id;
                this.color = color;
                this.controls = controls;
                this.size = 2.0;
                this.score = 0;
                this.goalC = 0;
                this.goalR = 0;
                this.lastDir = {
                    x: id === 0 ? 1 : -1,
                    y: 0
                };

                // AI Memory
                this.lastPos = {
                    x: 0,
                    y: 0
                };
                this.stuckCounter = 0;
                this.forceUnstuckTimer = 0;
                this.unstuckDir = {
                    x: 0,
                    y: 0
                };
                this.resetState();
            }

            resetState() {
                this.minesLeft = CONFIG.MAX_MINES;
                this.lastMineTime = 0;
                this.trail = [];
                this.boostEnergy = 100;
                this.boostCooldown = 0;
                this.portalCooldown = 0;
                this.stunTime = 0;
                this.glitchTime = 0;
                this.shieldActive = false;
                this.currentSpeed = CONFIG.BASE_SPEED;
                this.prevDetonateKey = false;
                this.beamPixels = [];
                this.beamIdx = 0;
                this.isCharging = false;
                this.chargeStartTime = 0;
                this.chargeGrace = 0;
                this.botPath = [];
                this.botNextCell = null;
                this.botRetargetTimer = 0;
                this.stuckCounter = 0;
                this.forceUnstuckTimer = 0;
                this.isDead = false;
            }
        }

        /** * ==========================================
         * 3. GLOBAL STATE
         * ==========================================
         */

        const canvas = document.getElementById('ledMatrix');
        const ctx = canvas.getContext('2d');

        // OFFSCREEN BUFFER
        const bgCanvas = document.createElement('canvas');
        const bgCtx = bgCanvas.getContext('2d');
        let isBgRendered = false; // Flag to ensure we only draw it once

        const STATE = {
            screen: 'MENU',
            gameMode: 'SINGLE',
            maze: [],
            players: [],
            mines: [],
            particles: [],
            portals: [],
            projectiles: [],
            ammoCrate: null,
            ammoRespawnTimer: 0,
            keys: {},
            gameTime: 0,
            maxGameTime: 0,
            isGameOver: false,
            isRoundOver: false,
            deathTimer: 0,
            victimIdx: -1,
            looser: -1,
            isDraw: false,
            messages: {
                deathReason: "",
                win: "",
                taunt: "",
                round: "",
                winColor: "#fff",
                roundColor: "#fff"
            },
            scrollX: 0,
            sfx: new SoundFX()
        };

        /** * ==========================================
         * 4. GRID & PHYSICS HELPERS
         * ==========================================
         */
        function gridIndex(c, r) {
            if (c < 0 || r < 0 || c >= CONFIG.COLS || r >= CONFIG.ROWS) return undefined;
            return STATE.maze[c + r * CONFIG.COLS];
        }

        function removeWalls(a, b) {
            let x = a.c - b.c;
            if (x === 1) {
                a.walls[3] = false;
                b.walls[1] = false;
            }
            if (x === -1) {
                a.walls[1] = false;
                b.walls[3] = false;
            }
            let y = a.r - b.r;
            if (y === 1) {
                a.walls[0] = false;
                b.walls[2] = false;
            }
            if (y === -1) {
                a.walls[2] = false;
                b.walls[0] = false;
            }
        }

        function isWall(pixelX, pixelY) {
            if (pixelX < CONFIG.MAZE_OFFSET_X || pixelX >= CONFIG.LOGICAL_W - CONFIG.HUD_WIDTH) return true;
            if (pixelY < 0 || pixelY >= CONFIG.LOGICAL_H) return true;

            let mx = pixelX - CONFIG.MAZE_OFFSET_X;
            let cell = gridIndex(Math.floor(mx / CONFIG.CELL_SIZE), Math.floor(pixelY / CONFIG.CELL_SIZE));

            if (!cell) return true;

            let lx = Math.floor(mx) % CONFIG.CELL_SIZE;
            let ly = Math.floor(pixelY) % CONFIG.CELL_SIZE;

            if (lx === 0 && ly === 0) return true;
            if (ly === 0 && cell.walls[0]) return true;
            if (lx === 0 && cell.walls[3]) return true;
            return false;
        }

        function checkPlayerCollision(p, dx, dy) {
            let nx = p.x + dx;
            let ny = p.y + dy;
            let hitbox = 0.8;
            let pad = 0.6;
            return (
                isWall(nx + pad, ny + pad) ||
                isWall(nx + pad + hitbox, ny + pad) ||
                isWall(nx + pad, ny + pad + hitbox) ||
                isWall(nx + pad + hitbox, ny + pad + hitbox)
            );
        }

        function destroyWallAt(c, r) {
            // FIX: Removed the restrictive line that returned early for edge cells
            let cell = gridIndex(c, r);
            if (!cell) return;

            // 1. Destroy TOP wall (Index 0) - ONLY if not the absolute map top border
            if (r > 0) {
                cell.walls[0] = false;
                let top = gridIndex(c, r - 1);
                if (top) top.walls[2] = false;
            }

            // 2. Destroy RIGHT wall (Index 1) - ONLY if not the absolute map right border
            if (c < CONFIG.COLS - 1) {
                cell.walls[1] = false;
                let right = gridIndex(c + 1, r);
                if (right) right.walls[3] = false;
            }

            // 3. Destroy BOTTOM wall (Index 2) - ONLY if not the absolute map bottom border
            if (r < CONFIG.ROWS - 1) {
                cell.walls[2] = false;
                let bottom = gridIndex(c, r + 1);
                if (bottom) bottom.walls[0] = false;
            }

            // 4. Destroy LEFT wall (Index 3) - ONLY if not the absolute map left border
            if (c > 0) {
                cell.walls[3] = false;
                let left = gridIndex(c - 1, r);
                if (left) left.walls[1] = false;
            }
        }
        /** * ==========================================
         * 5. GAME FLOW & GENERATION
         * ==========================================
         */
        function initMaze() {
            STATE.maze = [];
            for (let r = 0; r < CONFIG.ROWS; r++) {
                for (let c = 0; c < CONFIG.COLS; c++) {
                    STATE.maze.push(new Cell(c, r));
                }
            }

            let stack = [];
            let current = STATE.maze[0];
            current.visited = true;

            while (true) {
                let neighbors = [];
                let top = gridIndex(current.c, current.r - 1);
                let right = gridIndex(current.c + 1, current.r);
                let bottom = gridIndex(current.c, current.r + 1);
                let left = gridIndex(current.c - 1, current.r);

                if (top && !top.visited) neighbors.push(top);
                if (right && !right.visited) neighbors.push(right);
                if (bottom && !bottom.visited) neighbors.push(bottom);
                if (left && !left.visited) neighbors.push(left);

                if (neighbors.length > 0) {
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    next.visited = true;
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                } else if (stack.length > 0) {
                    current = stack.pop();
                } else {
                    break;
                }
            }
            resetRoundEntities();
        }

        function resetRoundEntities() {
            STATE.players[0].x = CONFIG.MAZE_OFFSET_X + 1;
            STATE.players[0].y = 1;
            STATE.players[0].goalC = CONFIG.COLS - 1;
            STATE.players[0].goalR = CONFIG.ROWS - 1;
            STATE.players[0].resetState();

            let endX = CONFIG.MAZE_OFFSET_X + ((CONFIG.COLS - 1) * CONFIG.CELL_SIZE) + 1;
            let endY = ((CONFIG.ROWS - 1) * CONFIG.CELL_SIZE) + 1;
            STATE.players[1].x = endX;
            STATE.players[1].y = endY;
            STATE.players[1].goalC = 0;
            STATE.players[1].goalR = 0;
            STATE.players[1].resetState();

            STATE.mines = [];
            STATE.particles = [];
            STATE.projectiles = [];

            STATE.portals = [];
            let attempts = 0;
            while (STATE.portals.length < 2 && attempts < 100) {
                attempts++;
                let c = Math.floor(Math.random() * (CONFIG.COLS - 2)) + 1;
                let r = Math.floor(Math.random() * (CONFIG.ROWS - 2)) + 1;
                if ((c < 5 && r < 5) || (c > CONFIG.COLS - 5 && r > CONFIG.ROWS - 5)) continue;
                let tooClose = false;
                for (let p of STATE.portals) {
                    if (Math.abs(p.c - c) + Math.abs(p.r - r) < 10) tooClose = true;
                }
                if (tooClose) continue;
                STATE.portals.push({
                    c: c,
                    r: r,
                    x: CONFIG.MAZE_OFFSET_X + c * CONFIG.CELL_SIZE + 1.5,
                    y: r * CONFIG.CELL_SIZE + 1.5,
                    color: STATE.portals.length === 0 ? '#ffaa00' : '#00aaff'
                });
            }
            if (STATE.portals.length < 2) {
                STATE.portals = [{
                    c: 10,
                    r: 10,
                    x: CONFIG.MAZE_OFFSET_X + 10 * CONFIG.CELL_SIZE + 1.5,
                    y: 10 * CONFIG.CELL_SIZE + 1.5,
                    color: '#ffaa00'
                },
                {
                    c: 20,
                    r: 10,
                    x: CONFIG.MAZE_OFFSET_X + 20 * CONFIG.CELL_SIZE + 1.5,
                    y: 10 * CONFIG.CELL_SIZE + 1.5,
                    color: '#00aaff'
                }
                ];
            }

            STATE.ammoCrate = null;
            spawnAmmoCrate();
            calculateGameTime();
            STATE.isRoundOver = false;
        }

        function spawnAmmoCrate() {
            let c = Math.floor(Math.random() * (CONFIG.COLS - 2)) + 1;
            let r = Math.floor(Math.random() * (CONFIG.ROWS - 2)) + 1;
            STATE.ammoCrate = {
                x: CONFIG.MAZE_OFFSET_X + c * CONFIG.CELL_SIZE + 0.5,
                y: r * CONFIG.CELL_SIZE + 0.5,
                c: c,
                r: r
            };
        }

        function calculateGameTime() {
            let start = gridIndex(0, 0);
            let end = gridIndex(CONFIG.COLS - 1, CONFIG.ROWS - 1);
            STATE.maze.forEach(c => {
                c.bfsVisited = false;
                c.parent = null;
            });

            let q = [start];
            start.bfsVisited = true;
            let len = 0;

            while (q.length > 0) {
                let curr = q.shift();
                if (curr === end) {
                    while (curr.parent) {
                        len++;
                        curr = curr.parent;
                    }
                    break;
                }
                [
                    [0, -1, 0],
                    [1, 0, 1],
                    [0, 1, 2],
                    [-1, 0, 3]
                ].forEach(d => {
                    let n = gridIndex(curr.c + d[0], curr.r + d[1]);
                    if (n && !n.bfsVisited && !curr.walls[d[2]]) {
                        n.bfsVisited = true;
                        n.parent = curr;
                        q.push(n);
                    }
                });
            }
            STATE.gameTime = Math.floor((len * CONFIG.CELL_SIZE / ((CONFIG.BASE_SPEED + CONFIG.MAX_SPEED) / 2)) * 6);
            STATE.maxGameTime = STATE.gameTime;
        }

        /** * ==========================================
         * 6. INPUT & AI LOGIC
         * ==========================================
         */

        function initTouchControls() {
            const buttons = document.querySelectorAll('.btn');
            buttons.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (STATE.sfx) STATE.sfx.init();
                    const code = btn.getAttribute('data-key');
                    STATE.keys[code] = true;

                    if ((STATE.isGameOver || STATE.isRoundOver) && (code === 'KeyR' || code === 'KeyStart' || code === 'KeySelect')) {
                        if (STATE.isGameOver) startGame(); else initMaze();
                    }
                    if (STATE.screen === 'MENU') { STATE.gameMode = 'SINGLE'; startGame(); }
                }, { passive: false });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const code = btn.getAttribute('data-key');
                    STATE.keys[code] = false;
                }, { passive: false });
            });

            // if (window.innerWidth > 1024) return; 

            const joystickZone = document.getElementById('joystick-zone');

            const manager = nipplejs.create({
                zone: joystickZone,
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white',
                size: 100
            });

            function resetMoveKeys() {
                STATE.keys['KeyW'] = false;
                STATE.keys['KeyS'] = false;
                STATE.keys['KeyA'] = false;
                STATE.keys['KeyD'] = false;
            }

            manager.on('start', () => {
                if (STATE.sfx) STATE.sfx.init();
            });

            manager.on('move', (evt, data) => {
                resetMoveKeys();
                if (data.direction) {
                    const dir = data.direction;
                    if (dir.angle === 'up' || dir.y === 'up') STATE.keys['KeyW'] = true;
                    if (dir.angle === 'down' || dir.y === 'down') STATE.keys['KeyS'] = true;
                    if (dir.angle === 'left' || dir.x === 'left') STATE.keys['KeyA'] = true;
                    if (dir.angle === 'right' || dir.x === 'right') STATE.keys['KeyD'] = true;

                    if (STATE.screen === 'MENU') { STATE.gameMode = 'SINGLE'; startGame(); }
                }
            });

            manager.on('end', (evt, data) => {
                resetMoveKeys();
            });
        }
        /** * ==========================================
         * NATIVE GAMEPAD POLLING (NEW)
         * ==========================================
         */
        function pollGamepads() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gpInput = {
                p1: {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                    shield: false,
                    beam: false,
                    mine: false,
                    boost: false,
                    boom: false
                },
                p2: {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                    shield: false,
                    beam: false,
                    mine: false,
                    boost: false,
                    boom: false
                }
            };

            for (let i = 0; i < gamepads.length; i++) {
                const gp = gamepads[i];
                if (!gp) continue;

                // make the assamption that the 1st gamepad belong to  Player 1
                let target = (i === 0) ? gpInput.p1 : gpInput.p2;

                // D-PAD / AXES  (Analog Stick)
                if (gp.axes[1] < -CONFIG.GAMEPAD_THRESH) target.up = true;
                if (gp.axes[1] > CONFIG.GAMEPAD_THRESH) target.down = true;
                if (gp.axes[0] < -CONFIG.GAMEPAD_THRESH) target.left = true;
                if (gp.axes[0] > CONFIG.GAMEPAD_THRESH) target.right = true;

                // SNES Style mapping (Standard HTML5 Gamepad Layout) B=0, A=1, Y=2, X=3, L=4, R=5
                if (gp.buttons[12]?.pressed) target.up = true; // D-Pad Up
                if (gp.buttons[13]?.pressed) target.down = true; // D-Pad Down
                if (gp.buttons[14]?.pressed) target.left = true; // D-Pad Left
                if (gp.buttons[15]?.pressed) target.right = true; // D-Pad Right

                if (gp.buttons[0]?.pressed) target.mine = true; // Button B (Bottom)
                if (gp.buttons[1]?.pressed) target.boom = true; // Button A (Right)
                if (gp.buttons[2]?.pressed) target.beam = true; // Button Y (Left)
                if (gp.buttons[3]?.pressed) target.shield = true; // Button X (Top)
                if (gp.buttons[4]?.pressed) target.boost = true; // L Shoulder
                if (gp.buttons[5]?.pressed) target.boost = true; // R Shoulder
                if (gp.buttons[9]?.pressed) { // Start Button -> Reset
                    if (STATE.isGameOver || STATE.isRoundOver) startGame();
                }
            }
            return gpInput;
        }

        function getHumanInput(playerIdx, controls) {
            const gpData = pollGamepads();
            const gp = (playerIdx === 0) ? gpData.p1 : gpData.p2;
            return {
                up: STATE.keys[controls.up] || gp.up,
                down: STATE.keys[controls.down] || gp.down,
                left: STATE.keys[controls.left] || gp.left,
                right: STATE.keys[controls.right] || gp.right,
                shield: STATE.keys[controls.shield] || gp.shield,
                beam: STATE.keys[controls.beam] || gp.beam,
                mine: STATE.keys[controls.mine] || gp.mine,
                boost: STATE.keys[controls.boost] || gp.boost,
                boom: STATE.keys[controls.boom] || gp.boom
            };
        }

        function findPath(cpu, targetC, targetR, ignoreMines) {
            let start = gridIndex(Math.floor((cpu.x - CONFIG.MAZE_OFFSET_X) / CONFIG.CELL_SIZE), Math.floor(cpu.y / CONFIG.CELL_SIZE));
            let end = gridIndex(targetC, targetR);
            if (!start || !end) return null;

            STATE.maze.forEach(c => {
                c.bfsVisited = false;
                c.parent = null;
            });
            let q = [start];
            start.bfsVisited = true;
            let found = false;

            while (q.length > 0) {
                let curr = q.shift();
                if (curr === end) {
                    found = true;
                    break;
                }

                [
                    [0, -1, 0],
                    [1, 0, 1],
                    [0, 1, 2],
                    [-1, 0, 3]
                ].forEach(d => {
                    let n = gridIndex(curr.c + d[0], curr.r + d[1]);
                    let isSafe = true;
                    if (n && !ignoreMines) {
                        let mx = CONFIG.MAZE_OFFSET_X + n.c * CONFIG.CELL_SIZE + 1.5;
                        let my = n.r * CONFIG.CELL_SIZE + 1.5;
                        if (STATE.mines.some(m => m.active && Math.abs(m.x - mx) < 3 && Math.abs(m.y - my) < 3)) {
                            isSafe = false;
                        }
                    }
                    if (n && !n.bfsVisited && !curr.walls[d[2]] && isSafe) {
                        n.bfsVisited = true;
                        n.parent = curr;
                        q.push(n);
                    }
                });
            }

            if (found) {
                let path = [];
                let t = end;
                while (t) {
                    path.push(t);
                    t = t.parent;
                }
                path.reverse();
                return path;
            }
            return null;
        }

        function getCpuInput(cpu, opponent) {
            let cmd = {
                up: false,
                down: false,
                left: false,
                right: false,
                shield: false,
                beam: false,
                mine: false,
                boost: false,
                boom: false
            };

            // 1. DANGER SENSE
            let threat = null;
            let minDist = 999;
            STATE.projectiles.forEach(proj => {
                if (proj.owner !== cpu.id) {
                    let d = Math.hypot(proj.x - cpu.x, proj.y - cpu.y);
                    if (d < 30 && d < minDist) {
                        threat = proj;
                        minDist = d;
                    }
                }
            });
            let immediateMine = STATE.mines.find(m => m.active && Math.hypot(m.x - cpu.x, m.y - cpu.y) < 6);

            // 2. DEFENSE
            if (threat && minDist < 6 && cpu.boostEnergy > 20) cmd.shield = true;
            if (immediateMine && cpu.boostEnergy > 20) cmd.shield = true;

            // 3. ATTACK
            let dx = opponent.x - cpu.x;
            let dy = opponent.y - cpu.y;
            let distOpp = Math.hypot(dx, dy);

            if (!cmd.shield && cpu.boostEnergy > 30) {
                if (Math.abs(dx) < 30 && Math.abs(dy) < 4) cmd.beam = true;
                else if (Math.abs(dy) < 30 && Math.abs(dx) < 4) cmd.beam = true;
            }

            // 4. STUCK DETECTION
            let distMoved = Math.hypot(cpu.x - cpu.lastPos.x, cpu.y - cpu.lastPos.y);
            if (distMoved < 0.1) cpu.stuckCounter++;
            else cpu.stuckCounter = 0;
            cpu.lastPos = {
                x: cpu.x,
                y: cpu.y
            };

            if (cpu.stuckCounter > 20) {
                cpu.forceUnstuckTimer = 15;
                cpu.stuckCounter = 0;
                let dirs = [{
                    x: 0,
                    y: -1
                }, {
                    x: 0,
                    y: 1
                }, {
                    x: -1,
                    y: 0
                }, {
                    x: 1,
                    y: 0
                }];
                let validDirs = dirs.filter(d => !isWall(cpu.x + d.x * 2, cpu.y + d.y * 2));
                cpu.unstuckDir = validDirs.length > 0 ? validDirs[Math.floor(Math.random() * validDirs.length)] : dirs[0];
            }

            if (cpu.forceUnstuckTimer > 0) {
                cpu.forceUnstuckTimer--;
                if (cpu.unstuckDir.y < 0) cmd.up = true;
                if (cpu.unstuckDir.y > 0) cmd.down = true;
                if (cpu.unstuckDir.x < 0) cmd.left = true;
                if (cpu.unstuckDir.x > 0) cmd.right = true;
                return cmd;
            }

            // 5. NAVIGATION
            if (!cpu.botNextCell || cpu.botRetargetTimer <= 0 || threat) {
                let path = findPath(cpu, cpu.goalC, cpu.goalR, false);
                if (!path) path = findPath(cpu, cpu.goalC, cpu.goalR, true);

                if (path && path.length > 1) cpu.botNextCell = path[1];
                else if (path && path.length > 0) cpu.botNextCell = path[0];
                else cpu.botNextCell = null;

                cpu.botRetargetTimer = 10;
            }
            cpu.botRetargetTimer--;

            if (cpu.botNextCell) {
                let tx = CONFIG.MAZE_OFFSET_X + cpu.botNextCell.c * CONFIG.CELL_SIZE + 0.5;
                let ty = cpu.botNextCell.r * CONFIG.CELL_SIZE + 0.5;

                let steppingOnMine = STATE.mines.some(m => m.active && Math.abs(m.x - tx) < 3 && Math.abs(m.y - ty) < 3);
                if (steppingOnMine && cpu.boostEnergy > 20) cmd.shield = true;

                let diffX = tx - cpu.x;
                let diffY = ty - cpu.y;
                if (Math.abs(diffX) > 0.1) {
                    if (diffX < 0) cmd.left = true;
                    else cmd.right = true;
                }
                if (Math.abs(diffY) > 0.1) {
                    if (diffY < 0) cmd.up = true;
                    else cmd.down = true;
                }
            }

            // 6. UTILITY
            if (distOpp < 8 && cpu.minesLeft > 0 && Math.random() < 0.05) cmd.mine = true;
            if (cpu.botNextCell && !threat && cpu.boostEnergy > 80 && Math.random() < 0.05) cmd.boost = true;

            STATE.mines.forEach(m => {
                if (m.owner === cpu.id && Math.hypot(m.x - opponent.x, m.y - opponent.y) < 5) cmd.boom = true;
            });

            return cmd;
        }

        /** * ==========================================
         * 7. CORE GAME LOOP & PHYSICS
         * ==========================================
         */

        function applyPlayerActions(p, input) {
            let now = Date.now();

            // Detonate
            if (input.boom && !p.prevDetonateKey) {
                if (p.boostEnergy >= CONFIG.DETONATE_COST) {
                    let minesFound = false;
                    for (let i = STATE.mines.length - 1; i >= 0; i--) {
                        if (STATE.mines[i].owner === p.id) {
                            triggerExplosion(STATE.mines[i].x, STATE.mines[i].y, "KILLED BY REMOTE DETONATION");
                            STATE.mines.splice(i, 1);
                            minesFound = true;
                        }
                    }
                    if (minesFound) p.boostEnergy -= CONFIG.DETONATE_COST;
                }
            }
            p.prevDetonateKey = input.boom;

            // Shield
            if (input.shield && p.boostEnergy > 0) {
                if (!p.shieldActive) STATE.sfx.shield();
                p.shieldActive = true;
                p.boostEnergy -= CONFIG.SHIELD_DRAIN;
            } else {
                p.shieldActive = false;
            }

            // Beam
            if (input.beam) {
                p.chargeGrace = 0;
                if (!p.isCharging) {
                    p.isCharging = true;
                    p.chargeStartTime = now;
                }
                if (now - p.chargeStartTime > CONFIG.CHARGE_TIME) {
                    fireChargedBeam(p);
                    p.isCharging = false;
                    p.chargeStartTime = 0;
                } else if (p.isCharging && Math.floor(now / 100) % 5 === 0) {
                    STATE.sfx.charge();
                }
            } else {
                if (p.isCharging) {
                    p.chargeGrace++;
                    if (now - p.chargeStartTime < CONFIG.CHARGE_TIME) fireBeam(p);
                    p.isCharging = false;
                }
                // Reset
                p.isCharging = false;
                p.chargeStartTime = 0;
                p.chargeGrace = 0;
            }

            // Movement
            let speed = CONFIG.BASE_SPEED;
            if (p.stunTime > 0) {
                speed = CONFIG.BASE_SPEED * 0.8;
                if (!input.boost && !p.shieldActive) p.boostEnergy = Math.min(100, p.boostEnergy + CONFIG.BOOST_REGEN);
            } else if (p.isCharging) {
                speed = CONFIG.BASE_SPEED * CONFIG.CHARGE_PENALTY;
                p.boostEnergy = Math.min(100, p.boostEnergy + CONFIG.BOOST_REGEN);
            } else {
                if (p.boostCooldown > 0) {
                    p.boostCooldown--;
                    if (!p.shieldActive) p.boostEnergy = Math.min(100, p.boostEnergy + CONFIG.BOOST_REGEN);
                } else if (input.boost && p.boostEnergy > 0) {
                    p.boostEnergy -= CONFIG.BOOST_DRAIN;
                    speed = CONFIG.MAX_SPEED;
                    if (p.boostEnergy <= 0) p.boostEnergy = 0;
                } else {
                    if (p.boostEnergy <= 0) p.boostCooldown = CONFIG.BOOST_COOLDOWN_FRAMES;
                    else if (!p.shieldActive) p.boostEnergy = Math.min(100, p.boostEnergy + CONFIG.BOOST_REGEN);
                }
            }
            p.currentSpeed = speed;

            let dx = 0,
                dy = 0;
            if (input.up) dy = -speed;
            if (input.down) dy = speed;
            if (input.left) dx = -speed;
            if (input.right) dx = speed;

            if (p.glitchTime > 0) {
                dx = -dx;
                dy = -dy;
            }

            if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                if (Math.abs(dx) > Math.abs(dy)) p.lastDir = {
                    x: dx > 0 ? 1 : -1,
                    y: 0
                };
                else p.lastDir = {
                    x: 0,
                    y: dy > 0 ? 1 : -1
                };
            }

            let dist = Math.hypot(dx, dy);
            let steps = Math.ceil(dist / 0.5);
            let sx = dx / steps;
            let sy = dy / steps;

            for (let i = 0; i < steps; i++) {
                if (sx !== 0 && !checkPlayerCollision(p, sx, 0)) p.x += sx;
                if (sy !== 0 && !checkPlayerCollision(p, 0, sy)) p.y += sy;
            }

            // Mine Drop
            if (input.mine && p.minesLeft > 0 && now - p.lastMineTime > CONFIG.MINE_COOLDOWN) {
                STATE.sfx.mineDrop();
                p.lastMineTime = now;
                p.minesLeft--;
                STATE.mines.push({
                    x: Math.floor(p.x),
                    y: Math.floor(p.y),
                    droppedAt: now,
                    active: false,
                    visX: Math.floor(Math.random() * 2),
                    visY: Math.floor(Math.random() * 2),
                    owner: p.id
                });
            }

            // Goal
            let gx = CONFIG.MAZE_OFFSET_X + (p.goalC * CONFIG.CELL_SIZE) + 1;
            let gy = (p.goalR * CONFIG.CELL_SIZE) + 1;
            if (Math.abs(p.x - gx) < 1.0 && Math.abs(p.y - gy) < 1.0) {
                p.score += 2;
                if (p.score >= CONFIG.MAX_SCORE) {
                    STATE.isGameOver = true;
                    STATE.looser = p.id == 0 ? 1 : 2;
                    STATE.messages.win = `PLAYER ${p.id + 1} WINS!`;
                    STATE.messages.taunt = TAUNTS[Math.floor(Math.random() * TAUNTS.length)];
                    STATE.messages.winColor = p.color;
                    STATE.scrollX = CONFIG.LOGICAL_W + 5;
                } else {
                    STATE.isRoundOver = true;
                    STATE.messages.round = `PLAYER ${p.id + 1} SCORES!`;
                    STATE.messages.roundColor = p.color;
                    STATE.scrollX = CONFIG.LOGICAL_W + 5;
                }
            }
        }

        function triggerExplosion(x, y, reason = "EXPLODED") {
            STATE.sfx.explosion();

            const BLAST_RADIUS = 4.0;
            let centerC = Math.floor((x - CONFIG.MAZE_OFFSET_X) / CONFIG.CELL_SIZE);
            let centerR = Math.floor(y / CONFIG.CELL_SIZE);
            let cellRadius = 1;

            // --- Wall Destruction Logic ---
            for (let r = centerR - cellRadius; r <= centerR + cellRadius; r++) {
                for (let c = centerC - cellRadius; c <= centerC + cellRadius; c++) {
                    if (c < 0 || c >= CONFIG.COLS || r < 0 || r >= CONFIG.ROWS) continue;
                    let dc = c - centerC;
                    let dr = r - centerR;
                    if (dc * dc + dr * dr <= 2) {
                        destroyWallAt(c, r);
                    }
                }
            }

            // --- Particle Spawning ---
            const PARTICLE_COUNT = 30;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let angle = Math.random() * Math.PI * 2;
                let speed = Math.random() * 3.5;
                STATE.particles.push({
                    x: x + 1,
                    y: y + 1,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    decay: 0.03 + Math.random() * 0.04,
                    life: 1.0,
                    color: '#ffffff'
                });
            }

            // --- Player Damage Logic (FIXED) ---
            // 1. Collect all victims first
            let hitIndices = [];
            if (!STATE.isRoundOver && !STATE.isGameOver) {
                STATE.players.forEach((p, idx) => {
                    if (Math.abs(p.x + 1 - (x + 1)) < BLAST_RADIUS && Math.abs(p.y + 1 - (y + 1)) < BLAST_RADIUS) {
                        if (!p.shieldActive && !p.isDead) {
                            hitIndices.push(idx);
                        }
                    }
                });
            }

            // 2. Process deaths if anyone was hit
            if (hitIndices.length > 0) {
                handleMultiDeath(hitIndices, reason);
            }
        }

        function handleMultiDeath(indices, reason) {
            if (STATE.isGameOver || STATE.isRoundOver || STATE.deathTimer > 0) return;

            // Set global death state
            STATE.deathTimer = 50;
            STATE.deathReason = reason || "ELIMINATED";
            STATE.sfx.death();

            // Check for Draw
            if (indices.length > 1) {
                STATE.isDraw = true; // Mark as draw
            } else {
                STATE.victimIdx = indices[0]; // Mark single victim
                STATE.isDraw = false;
            }

            // Apply death effects to ALL victims
            indices.forEach(idx => {
                let p = STATE.players[idx];
                p.isDead = true;

                // Visual effects for each player
                for (let i = 0; i < 30; i++) {
                    STATE.particles.push({
                        x: p.x + 1,
                        y: p.y + 1,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 1.5,
                        color: p.color
                    });
                }
            });
        }
        function handlePlayerDeath(victimIdx, reason) {
            if (STATE.isGameOver || STATE.isRoundOver || STATE.deathTimer > 0) return;

            // 1. Mark player as dead
            STATE.players[victimIdx].isDead = true;
            STATE.victimIdx = victimIdx;
            // 2. Store the reason in the global state (add this property implicitly)
            STATE.deathReason = reason || "ELIMINATED BY A SNEAKY BUG";
            // 3. Start the Death Timer 
            STATE.deathTimer = 50;

            // 4. Extra visual effects
            let p = STATE.players[victimIdx];
            STATE.sfx.death();

            for (let i = 0; i < 30; i++) {
                STATE.particles.push({
                    x: p.x + 1,
                    y: p.y + 1,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1.5,
                    color: p.color
                });
            }
        }

        function fireChargedBeam(p) {
            if (p.boostEnergy < CONFIG.CHARGED_BEAM_COST) return;
            p.boostEnergy -= CONFIG.CHARGED_BEAM_COST;
            STATE.sfx.chargedShoot();

            STATE.projectiles.push({
                x: p.x + (p.size / 2),
                y: p.y + (p.size / 2),
                vx: p.lastDir.x * CONFIG.C_BEAM_SPEED,
                vy: p.lastDir.y * CONFIG.C_BEAM_SPEED,
                distTraveled: 0,
                owner: p.id,
                color: p.color
            });

            for (let i = 0; i < 10; i++) {
                STATE.particles.push({
                    x: p.x + 1,
                    y: p.y + 1,
                    vx: (Math.random() - 0.5),
                    vy: (Math.random() - 0.5),
                    life: 0.8,
                    color: '#fff'
                });
            }
        }

        function fireBeam(p) {
            if (p.boostEnergy < CONFIG.BEAM_ENERGY_COST) return;
            if (p.beamIdx < p.beamPixels.length) return;
            p.boostEnergy -= CONFIG.BEAM_ENERGY_COST;
            STATE.sfx.shoot();

            let start = gridIndex(Math.floor((p.x - CONFIG.MAZE_OFFSET_X + 1) / CONFIG.CELL_SIZE), Math.floor((p.y + 1) / CONFIG.CELL_SIZE));
            let end = gridIndex(p.goalC, p.goalR);
            if (!start || !end) return;

            STATE.maze.forEach(c => {
                c.parent = null;
                c.bfsVisited = false;
            });
            let queue = [start];
            start.bfsVisited = true;
            let found = false;

            while (queue.length > 0) {
                let curr = queue.shift();
                if (curr === end) {
                    found = true;
                    break;
                }
                [
                    [0, -1, 0],
                    [1, 0, 1],
                    [0, 1, 2],
                    [-1, 0, 3]
                ].forEach(d => {
                    let n = gridIndex(curr.c + d[0], curr.r + d[1]);
                    if (n && !n.bfsVisited && !curr.walls[d[2]]) {
                        n.bfsVisited = true;
                        n.parent = curr;
                        queue.push(n);
                    }
                });
            }
            if (!found) return;

            let pathCells = [];
            let temp = end;
            while (temp) {
                pathCells.push(temp);
                temp = temp.parent;
            }
            pathCells.reverse();

            p.beamPixels = [];
            for (let i = 0; i < pathCells.length - 1; i++) {
                let x1 = CONFIG.MAZE_OFFSET_X + (pathCells[i].c * CONFIG.CELL_SIZE) + 1;
                let y1 = (pathCells[i].r * CONFIG.CELL_SIZE) + 1;
                let x2 = CONFIG.MAZE_OFFSET_X + (pathCells[i + 1].c * CONFIG.CELL_SIZE) + 1;
                let y2 = (pathCells[i + 1].r * CONFIG.CELL_SIZE) + 1;

                p.beamPixels.push({
                    x: x1,
                    y: y1
                });
                let dx = (x2 - x1) / 3;
                let dy = (y2 - y1) / 3;
                p.beamPixels.push({
                    x: x1 + dx,
                    y: y1 + dy
                });
                p.beamPixels.push({
                    x: x1 + dx * 2,
                    y: y1 + dy * 2
                });
            }
            p.beamPixels.push({
                x: CONFIG.MAZE_OFFSET_X + (pathCells[pathCells.length - 1].c * CONFIG.CELL_SIZE) + 1,
                y: (pathCells[pathCells.length - 1].r * CONFIG.CELL_SIZE) + 1
            });
            p.beamIdx = 0;
        }

        function finalizeRound() {
            // --- HANDLE DRAW ---
            if (STATE.isDraw) {
                STATE.messages.round = "DOUBLE KO! DRAW!";
                STATE.messages.roundColor = "#ffffff";
                STATE.sfx.roundOver(); // Play generic sound
                STATE.isRoundOver = true;
                STATE.scrollX = CONFIG.LOGICAL_W + 5;

                // Reset Logic
                STATE.deathTimer = 0;
                STATE.isDraw = false;
                return;
            }

            // --- STANDARD WINNER LOGIC ---
            let victimIdx = STATE.victimIdx;
            let winnerIdx = (victimIdx === 0) ? 1 : 0;

            STATE.players[winnerIdx].score++;
            STATE.messages.round = `P${victimIdx + 1} ${STATE.deathReason}!`;
            STATE.messages.roundColor = "#ff0000";

            if (STATE.players[winnerIdx].score >= CONFIG.MAX_SCORE) {
                STATE.sfx.win();
                STATE.isGameOver = true;
                STATE.looser = victimIdx == 0 ? 1 : 2; // Fixed logic
                STATE.messages.win = `PLAYER ${winnerIdx + 1} WINS!`;
                STATE.messages.taunt = TAUNTS[Math.floor(Math.random() * TAUNTS.length)];
                STATE.messages.winColor = STATE.players[winnerIdx].color;
                STATE.scrollX = CONFIG.LOGICAL_W + 5;
            } else {
                STATE.sfx.roundOver();
                STATE.isRoundOver = true;
                STATE.scrollX = CONFIG.LOGICAL_W + 5;
            }

            STATE.deathTimer = 0;
        }

        // --- Main Update ---
        function update() {
            if (STATE.screen === 'MENU') {
                if (STATE.keys['Digit1']) {
                    STATE.gameMode = 'SINGLE';
                    startGame();
                }
                if (STATE.keys['Digit2']) {
                    STATE.gameMode = 'MULTI';
                    startGame();
                }
                updateParticles();
                return;
            }

            if (STATE.deathTimer > 0) {
                STATE.deathTimer--;

                updateProjectiles();
                updateParticles();

                if (STATE.deathTimer <= 0) {
                    finalizeRound();
                }
                return;
            }

            if (STATE.isGameOver || STATE.isRoundOver) {
                updateParticles();
                STATE.scrollX -= 0.5;
                let msgLen = (STATE.isGameOver ? STATE.messages.taunt.length : STATE.messages.round.length);
                if (STATE.scrollX < -(msgLen * 4.5)) STATE.scrollX = CONFIG.LOGICAL_W;
                return;
            }
            updateProjectiles();
            if (STATE.gameTime <= 0) {
                STATE.isRoundOver = true;
                STATE.messages.round = "TIME OUT!";
                STATE.messages.roundColor = "#ffff00";
                STATE.scrollX = CONFIG.LOGICAL_W + 5;
                return;
            }
            STATE.gameTime -= 1;

            let now = Date.now();
            STATE.mines.forEach(m => {
                if (!m.active && now - m.droppedAt > CONFIG.MINE_ARM_TIME) m.active = true;
            });
            if (!STATE.ammoCrate) {
                STATE.ammoRespawnTimer++;
                if (STATE.ammoRespawnTimer > CONFIG.AMMO_RESPAWN_DELAY) {
                    spawnAmmoCrate();
                    STATE.ammoRespawnTimer = 0;
                }
            }

            let p1 = STATE.players[0];
            let p2 = STATE.players[1];
            if (p1.beamPixels.length > 0 && p2.beamPixels.length > 0) {
                let b1 = Math.floor(p1.beamIdx);
                let b2 = Math.floor(p2.beamIdx);
                if (b1 < p1.beamPixels.length && b2 < p2.beamPixels.length) {
                    let h1 = p1.beamPixels[b1];
                    let h2 = p2.beamPixels[b2];
                    if (Math.abs(h1.x - h2.x) + Math.abs(h1.y - h2.y) < 4) {
                        triggerExplosion((h1.x + h2.x) / 2, (h1.y + h2.y) / 2, "KILLED BY CHAIN REACTION");
                        p1.beamPixels = [];
                        p1.beamIdx = 9999;
                        p2.beamPixels = [];
                        p2.beamIdx = 9999;
                    }
                }
            }

            STATE.players.forEach((p, idx) => {
                if (STATE.ammoCrate && Math.abs((p.x + 1) - (STATE.ammoCrate.x + 1)) < 2 && Math.abs((p.y + 1) - (STATE.ammoCrate.y + 1)) < 2) {
                    p.minesLeft = CONFIG.MAX_MINES;
                    STATE.sfx.powerup();
                    STATE.ammoCrate = null;
                    STATE.ammoRespawnTimer = 0;
                }

                if (p.stunTime > 0) p.stunTime--;
                if (p.glitchTime > 0) p.glitchTime--;
                if (p.portalCooldown > 0) p.portalCooldown--;
                else {
                    let pc = Math.floor((p.x + p.size / 2 - CONFIG.MAZE_OFFSET_X) / CONFIG.CELL_SIZE);
                    let pr = Math.floor((p.y + p.size / 2) / CONFIG.CELL_SIZE);
                    let portal = STATE.portals.find(pt => pt.c === pc && pt.r === pr);
                    if (portal) {
                        let dest = STATE.portals.find(pt => pt !== portal);
                        if (dest) {
                            p.x = CONFIG.MAZE_OFFSET_X + dest.c * CONFIG.CELL_SIZE + 0.5;
                            p.y = dest.r * CONFIG.CELL_SIZE + 0.5;
                            p.portalCooldown = 60;
                            if (Math.random() < CONFIG.GLITCH_CHANCE) p.glitchTime = CONFIG.GLITCH_DURATION;
                        }
                    }
                }
                p.trail.push({
                    x: p.x,
                    y: p.y
                });
                if (p.trail.length > CONFIG.TRAIL_LENGTH) p.trail.shift();

                if (p.beamIdx < p.beamPixels.length + CONFIG.BEAM_LENGTH) p.beamIdx += 0.8;
                let opponent = STATE.players[(idx + 1) % 2];
                let tipIdx = Math.floor(opponent.beamIdx);
                if (tipIdx >= 0 && tipIdx < opponent.beamPixels.length) {
                    let tip = opponent.beamPixels[tipIdx];
                    if (Math.abs(p.x - tip.x) < 1.5 && Math.abs(p.y - tip.y) < 1.5) {
                        if (!p.shieldActive) {
                            p.stunTime = CONFIG.STUN_DURATION;
                            // // if (Math.random() < 0.5) 
                            p.glitchTime = CONFIG.STUN_DURATION;
                            STATE.sfx.charge();
                        }
                        opponent.beamPixels = [];
                        opponent.beamIdx = 9999;
                    }
                }

                for (let i = STATE.mines.length - 1; i >= 0; i--) {
                    let m = STATE.mines[i];
                    let bIdx = Math.floor(p.beamIdx);
                    if (bIdx >= 0 && bIdx < p.beamPixels.length) {
                        let bp = p.beamPixels[bIdx];
                        if (bp.x >= m.x - 1 && bp.x <= m.x + 3 && bp.y >= m.y - 1 && bp.y <= m.y + 3) {
                            triggerExplosion(m.x, m.y, "BAD LUCK");
                            STATE.mines.splice(i, 1);
                            p.beamPixels = [];
                            p.beamIdx = 9999;
                            continue;
                        }
                    }
                    if (m.active && p.x + p.size > m.x && p.x < m.x + 2 && p.y + p.size > m.y && p.y < m.y + 2) {
                        triggerExplosion(m.x, m.y, "STEPPED ON MINE");
                        STATE.mines.splice(i, 1);
                    }
                }

                let cmd = {};
                if (idx === 0) {
                    cmd = getHumanInput(idx, CONTROLS_P1);
                } else {
                    if (STATE.gameMode === 'SINGLE') cmd = getCpuInput(p, STATE.players[0]);
                    else cmd = getHumanInput(idx, CONTROLS_P2);
                }
                applyPlayerActions(p, cmd);
            });
            updateParticles();
        }

        function updateParticles() {
            for (let i = STATE.particles.length - 1; i >= 0; i--) {
                let p = STATE.particles[i];

                // Move
                p.x += p.vx;
                p.y += p.vy;

                // 1. ADD FRICTION (Air Resistance)
                // This makes particles burst fast then slow down nicely
                p.vx *= 0.85;
                p.vy *= 0.85;

                // Decay life
                p.life -= p.decay;

                // 2. DYNAMIC COLOR RAMP (Heat Cooling)
                // White -> Yellow -> Orange -> Red -> Fade
                if (p.life > 0.8) p.color = '#ffffff';       // White Hot
                else if (p.life > 0.5) p.color = '#ffff00';  // Yellow
                else if (p.life > 0.25) p.color = '#ff9900'; // Orange
                else p.color = '#660000';                    // Dark Red (Smoke)

                if (p.life <= 0) STATE.particles.splice(i, 1);
            }
        }

        function updateProjectiles() {

            // Projectiles Update
            for (let i = STATE.projectiles.length - 1; i >= 0; i--) {
                let proj = STATE.projectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.distTraveled += CONFIG.C_BEAM_SPEED;

                if (proj.distTraveled >= CONFIG.C_BEAM_RANGE) {
                    STATE.projectiles.splice(i, 1);
                    continue;
                }

                let hw = (Math.abs(proj.vx) > 0) ? CONFIG.C_BEAM_LENGTH / 2 : CONFIG.C_BEAM_WIDTH / 2;
                let hh = (Math.abs(proj.vx) > 0) ? CONFIG.C_BEAM_WIDTH / 2 : CONFIG.C_BEAM_LENGTH / 2;
                let tipX = proj.x + (proj.vx * 2);
                let tipY = proj.y + (proj.vy * 2);

                if (isWall(tipX, tipY)) {
                    let gc = Math.floor((tipX - CONFIG.MAZE_OFFSET_X) / CONFIG.CELL_SIZE);
                    let gr = Math.floor(tipY / CONFIG.CELL_SIZE);
                    destroyWallAt(gc, gr);
                    STATE.particles.push({
                        x: tipX,
                        y: tipY,
                        vx: proj.vx * 0.5,
                        vy: proj.vy * 0.5,
                        life: 0.5,
                        color: '#555'
                    });
                }

                for (let mIdx = STATE.mines.length - 1; mIdx >= 0; mIdx--) {
                    let m = STATE.mines[mIdx];
                    if (Math.abs(proj.x - m.x) < hw + 1 && Math.abs(proj.y - m.y) < hh + 1) {
                        triggerExplosion(m.x, m.y, "GOT CAUGHT");
                        STATE.mines.splice(mIdx, 1);
                    }
                }

                let oppId = (proj.owner + 1) % 2;
                let opp = STATE.players[oppId];
                let pLeft = opp.x;
                let pRight = opp.x + opp.size;
                let pTop = opp.y;
                let pBot = opp.y + opp.size;
                let bLeft = proj.x - hw;
                let bRight = proj.x + hw;
                let bTop = proj.y - hh;
                let bBot = proj.y + hh;

                if (bLeft < pRight && bRight > pLeft && bTop < pBot && bBot > pTop) {
                    if (!opp.shieldActive) {
                        handlePlayerDeath(oppId, "TOOK CHARGED SHOT");
                        STATE.projectiles.splice(i, 1);
                        return;
                    } else {
                        STATE.projectiles.splice(i, 1);
                        return;
                    }
                }
            }

        }

        /** * ==========================================
         * 8. RENDERING
         * ==========================================
         */

        function drawLED(lx, ly, color) {
            const cx = (lx * CONFIG.PITCH) + (CONFIG.PITCH / 2);
            const cy = (ly * CONFIG.PITCH) + (CONFIG.PITCH / 2);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(cx, cy, CONFIG.LED_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            // const cx = (lx * CONFIG.PITCH) + (CONFIG.PITCH / 2);
            // const cy = (ly * CONFIG.PITCH) + (CONFIG.PITCH / 2);
            // ctx.fillStyle = color;
            // const size = CONFIG.PITCH - 4;
            // ctx.fillRect(cx, cy, size, size);
        }

        function drawText(str, x, y, color) {
            str = str.toUpperCase();
            let cx = x;
            for (let i = 0; i < str.length; i++) {
                let map = BITMAP_FONT[str[i]];
                if (map) {
                    for (let p = 0; p < 15; p++) {
                        if (map[p]) drawLED(cx + (p % 3), y + Math.floor(p / 3), color);
                    }
                }
                cx += 4;
            }
        }

        function drawDigit(x, y, num, color, rotateDeg) {
            const map = DIGIT_MAP[num];
            for (let i = 0; i < 15; i++) {
                if (map[i]) {
                    let c = i % 3;
                    let r = Math.floor(i / 3);
                    let dx, dy;
                    if (rotateDeg === -90) {
                        dx = r;
                        dy = (2 - c);
                    } else if (rotateDeg === 90) {
                        dx = (4 - r);
                        dy = c;
                    } else {
                        dx = c;
                        dy = r;
                    }
                    drawLED(x + dx, y + dy, color);
                }
            }
        }

        function renderMenu() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < CONFIG.LOGICAL_H; y++)
                for (let x = 0; x < CONFIG.LOGICAL_W; x++) drawLED(x, y, '#111');

            drawText("SELECT MODE", 42, 10, "#fff");
            drawText("1. SINGLE PLAYER", 30, 25, Math.floor(Date.now() / 500) % 2 === 0 ? "#0ff" : "#555");
            drawText("2. MULTIPLAYER", 35, 35, Math.floor(Date.now() / 500) % 2 !== 0 ? "#f0f" : "#555");
            drawText("CPU: HARD", 45, 55, "#f55");
        }

        function renderGame() {
            // 1. Draw Background
            if (!isBgRendered) preRenderBackground();
            ctx.drawImage(bgCanvas, 0, 0);

            let timeRatio = STATE.maxGameTime > 0 ? Math.max(0, Math.min(1, STATE.gameTime / STATE.maxGameTime)) : 0;
            let hue = Math.floor(timeRatio * 180);
            let wallColor = `hsl(${hue}, 100%, 50%)`;

            // 2. Draw Maze Walls
            STATE.maze.forEach(c => {
                let x = c.c * CONFIG.CELL_SIZE + CONFIG.MAZE_OFFSET_X;
                let y = c.r * CONFIG.CELL_SIZE;

                // --- FIX: Remove floating dots in explosions ---
                // Only draw the corner post if it connects to an existing wall
                let drawCorner = false;

                // Check if this cell has a Top or Left wall attached to this corner
                if (c.walls[0] || c.walls[3]) drawCorner = true;

                // Check if neighbors have walls attached to this corner
                if (!drawCorner) {
                    let left = gridIndex(c.c - 1, c.r);
                    let top = gridIndex(c.c, c.r - 1);
                    if (left && left.walls[0]) drawCorner = true; // Left neighbor has Top wall
                    if (top && top.walls[3]) drawCorner = true;   // Top neighbor has Left wall
                }

                if (drawCorner) drawLED(x, y, wallColor);
                // ----------------------------------------------

                if (c.walls[0]) {
                    drawLED(x + 1, y, wallColor);
                    drawLED(x + 2, y, wallColor);
                }
                if (c.walls[3]) {
                    drawLED(x, y + 1, wallColor);
                    drawLED(x, y + 2, wallColor);
                }

                // Draw Edge Walls (Right/Bottom) for map borders
                if (c.c === CONFIG.COLS - 1) {
                    // Check if we need the top-right corner post
                    if (c.walls[1] || c.walls[0]) drawLED(x + 3, y, wallColor);
                    if (c.walls[1]) {
                        drawLED(x + 3, y + 1, wallColor);
                        drawLED(x + 3, y + 2, wallColor);
                    }
                }
                if (c.r === CONFIG.ROWS - 1) {
                    // Check if we need the bottom-left corner post
                    if (c.walls[2] || c.walls[3]) drawLED(x, y + 3, wallColor);
                    if (c.walls[2]) {
                        drawLED(x + 1, y + 3, wallColor);
                        drawLED(x + 2, y + 3, wallColor);
                    }
                }
                // Absolute bottom-right corner of the map
                if (c.c === CONFIG.COLS - 1 && c.r === CONFIG.ROWS - 1) {
                    drawLED(x + 3, y + 3, wallColor);
                }
            });

            // 3. Draw Goals
            let gc = Math.floor(Date.now() / 200) % 2 === 0 ? '#fff' : '#444';
            STATE.players.forEach(p => {
                let gx = CONFIG.MAZE_OFFSET_X + p.goalC * CONFIG.CELL_SIZE + 1;
                let gy = p.goalR * CONFIG.CELL_SIZE + 1;
                drawLED(gx, gy, gc);
                drawLED(gx + 1, gy, gc);
                drawLED(gx, gy + 1, gc);
                drawLED(gx + 1, gy + 1, gc);
            });

            // 4. Draw Portals & Ammo
            STATE.portals.forEach(p => {
                drawLED(p.x, p.y, p.color);
                drawLED(p.x + 1, p.y, p.color);
                drawLED(p.x, p.y + 1, p.color);
                drawLED(p.x + 1, p.y + 1, p.color);
            });
            if (STATE.ammoCrate) {
                drawLED(STATE.ammoCrate.x, STATE.ammoCrate.y, '#0f0');
                drawLED(STATE.ammoCrate.x + 1, STATE.ammoCrate.y, '#0f0');
                drawLED(STATE.ammoCrate.x, STATE.ammoCrate.y + 1, '#0f0');
                drawLED(STATE.ammoCrate.x + 1, STATE.ammoCrate.y + 1, '#0f0');
            }

            // 5. Draw Mines & Projectiles
            STATE.mines.forEach(m => drawLED(m.x + m.visX, m.y + m.visY, m.active ? (Date.now() % 200 < 100 ? '#f00' : '#800') : '#444'));
            STATE.projectiles.forEach(p => {
                let hw = (Math.abs(p.vx) > 0) ? CONFIG.C_BEAM_LENGTH / 2 : CONFIG.C_BEAM_WIDTH / 2;
                let hh = (Math.abs(p.vx) > 0) ? CONFIG.C_BEAM_WIDTH / 2 : CONFIG.C_BEAM_LENGTH / 2;
                let c = (Date.now() % 50 === 0) ? '#fff' : p.color;
                for (let py = Math.floor(p.y - hh); py <= Math.floor(p.y + hh); py++)
                    for (let px = Math.floor(p.x - hw); px <= Math.floor(p.x + hw); px++)
                        drawLED(px, py, c);
            });

            // 6. Draw Players
            STATE.players.forEach(p => {
                if (p.isDead) return;
                let rc = p.stunTime > 0 ? (Date.now() % 100 < 50 ? '#808' : p.color) : (p.glitchTime > 0 ? (Date.now() % 100 < 50 ? '#0f0' : p.color) : p.color);

                // Beam
                for (let k = 0; k < CONFIG.BEAM_LENGTH; k++) {
                    let i = Math.floor(p.beamIdx) - k;
                    if (i >= 0 && i < p.beamPixels.length) {
                        ctx.globalAlpha = 1 - (k / CONFIG.BEAM_LENGTH);
                        drawLED(p.beamPixels[i].x, p.beamPixels[i].y, rc);
                        ctx.globalAlpha = 1;
                    }
                }

                // Charge
                if (p.isCharging) {
                    let r = (Date.now() - p.chargeStartTime) / CONFIG.CHARGE_TIME;
                    if (r > 1) r = 1;
                    let cc = `hsl(${Math.floor((1 - r) * 120)},100%,50%)`;
                    let sx = Math.floor(p.x) - 1,
                        sy = Math.floor(p.y) - 1;
                    let perim = [{ x: 1, y: 0 }, { x: 2, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }, { x: 2, y: 3 }, { x: 1, y: 3 }, { x: 0, y: 2 }, { x: 0, y: 1 }];
                    let n = Math.ceil(8 * r);
                    for (let i = 0; i < n; i++)
                        drawLED(sx + perim[i].x, sy + perim[i].y, cc);
                }

                // Shield
                if (p.shieldActive) {
                    let sx = Math.floor(p.x) - 1,
                        sy = Math.floor(p.y) - 1;
                    let perim = [{ x: 1, y: 0 }, { x: 2, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }, { x: 2, y: 3 }, { x: 1, y: 3 }, { x: 0, y: 2 }, { x: 0, y: 1 }];
                    for (let i = 0; i < 8; i++)
                        drawLED(sx + perim[i].x, sy + perim[i].y, '#88f');
                }

                // Trail
                if (p.boostEnergy > 0 && p.currentSpeed > CONFIG.BASE_SPEED)
                    p.trail.forEach((t, i) => {
                        ctx.globalAlpha = 0.7;
                        drawLED(Math.floor(t.x), Math.floor(t.y), rc);
                        drawLED(Math.floor(t.x) + 1, Math.floor(t.y), rc);
                        ctx.globalAlpha = 1;
                    });

                drawLED(Math.floor(p.x), Math.floor(p.y), rc);
                drawLED(Math.floor(p.x) + 1, Math.floor(p.y), rc);
                drawLED(Math.floor(p.x), Math.floor(p.y) + 1, rc);
                drawLED(Math.floor(p.x) + 1, Math.floor(p.y) + 1, rc);
            });

            // 7. Draw Particles
            STATE.particles.forEach(p => drawLED(p.x, p.y, p.color));

            // 8. Draw HUD
            let p1 = STATE.players[0],
                p2 = STATE.players[1],
                s = Math.ceil(STATE.gameTime / 60).toString().padStart(3, '0');
            drawDigit(0, 0, parseInt(p1.score.toString().padStart(2, '0')[0]), '#0ff', 90);
            drawDigit(0, 4, parseInt(p1.score.toString().padStart(2, '0')[1]), '#0ff', 90);
            drawDigit(0, 10, p1.minesLeft, `hsl(${p1.minesLeft / 4 * 120},100%,50%)`, 90);
            for (let h = 0; h < Math.floor(p1.boostEnergy / 100 * 38); h++)
                for (let w = 0; w < 5; w++) drawLED(w, 14 + h, `hsl(${p1.boostEnergy / 100 * 120},100%,50%)`);

            drawDigit(0, 53, parseInt(s[0]), wallColor, 90);
            drawDigit(0, 57, parseInt(s[1]), wallColor, 90);
            drawDigit(0, 61, parseInt(s[2]), wallColor, 90);

            let rx = 123;
            drawDigit(rx, 61, parseInt(p2.score.toString().padStart(2, '0')[0]), '#f0f', -90);
            drawDigit(rx, 57, parseInt(p2.score.toString().padStart(2, '0')[1]), '#f0f', -90);
            drawDigit(rx, 51, p2.minesLeft, `hsl(${p2.minesLeft / 4 * 120},100%,50%)`, -90);
            for (let h = 0; h < Math.floor(p2.boostEnergy / 100 * 38); h++)
                for (let w = 0; w < 5; w++) drawLED(rx + w, 49 - h, `hsl(${p2.boostEnergy / 100 * 120},100%,50%)`);

            drawDigit(rx, 8, parseInt(s[0]), wallColor, -90);
            drawDigit(rx, 4, parseInt(s[1]), wallColor, -90);
            drawDigit(rx, 0, parseInt(s[2]), wallColor, -90);

            // 9. OVERLAY TEXT & DIMMER
            if (STATE.isGameOver || STATE.isRoundOver) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (STATE.isGameOver) {
                    if (Math.floor(Date.now() / 300) % 2 === 0)
                        drawText(STATE.messages.win, 38, 15, STATE.messages.winColor);
                    let msg = `P${STATE.looser}: '${STATE.messages.taunt}'`
                    drawText(msg, STATE.scrollX, 35, "#ff5555");
                    drawText("PRESS 'R' TO RESET", 30, 52, "#888");
                } else {
                    drawText("ROUND OVER", 46, 20, "#fff");
                    drawText(STATE.messages.round, STATE.scrollX, 40, STATE.messages.roundColor);
                    if (Math.floor(Date.now() / 500) % 2 === 0) drawText("PRESS 'START'", 42, 55, "#ffff00");
                }
            }
        }
        /** * ==========================================
         * 9. INIT & EVENT LISTENERS
         * ==========================================
         */

        function preRenderBackground() {
            bgCanvas.width = canvas.width;
            bgCanvas.height = canvas.height;

            // Fill black background
            bgCtx.fillStyle = '#000';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            // Draw the faint #222 LEDs once
            for (let y = 0; y < CONFIG.LOGICAL_H; y++) {
                for (let x = 0; x < CONFIG.LOGICAL_W; x++) {
                    // We inline the drawLED logic here for the offscreen context
                    const cx = (x * CONFIG.PITCH) + (CONFIG.PITCH / 2);
                    const cy = (y * CONFIG.PITCH) + (CONFIG.PITCH / 2);
                    bgCtx.fillStyle = '#222';
                    bgCtx.beginPath();
                    bgCtx.arc(cx, cy, CONFIG.LED_RADIUS, 0, Math.PI * 2);
                    bgCtx.fill();
                }
            }
            isBgRendered = true;
        }

        function startGame() {
            if (STATE.sfx) STATE.sfx.init();
            STATE.screen = 'PLAYING';
            STATE.isGameOver = false;
            STATE.isRoundOver = false;
            STATE.players = [new Player(0, '#00ffff', CONTROLS_P1), new Player(1, '#ff00ff', CONTROLS_P2)];
            document.getElementById('statusText').innerText = "GOAL: 5 POINTS";
            initMaze();
        }

        function loop() {
            update();
            if (STATE.screen === 'MENU') renderMenu();
            else renderGame();
            requestAnimationFrame(loop);
        }

        function toggleRules() {
            const modal = document.getElementById('mobile-rules-modal');
            if (modal.style.display === 'flex') {
                modal.style.display = 'none';
            } else {
                modal.style.display = 'flex';
            }
        }

        window.addEventListener('keydown', (e) => {
            if (STATE.sfx) STATE.sfx.init();
            let k = e.code;
            if (["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter"].includes(k)) e.preventDefault();
            STATE.keys[k] = true;

            if (k === 'Escape') {
                STATE.screen = 'MENU';
                document.getElementById('statusText').innerText = "SELECT MODE";
            }

            if (STATE.screen === 'PLAYING') {
                if (STATE.isGameOver && (k === 'KeyR' || k === 'KeyStart' || k === 'KeySelect')) {
                    startGame(); // Full Reset
                } else if (STATE.isRoundOver && (k === 'KeyR' || k === 'KeyStart' || k === 'KeySelect')) {
                    initMaze(); // Next Round (Keep Score)
                }
            }
        });
        window.addEventListener('keyup', (e) => STATE.keys[e.code] = false);

        window.addEventListener('load', () => {
            if (typeof nipplejs === 'undefined') {
                console.error("Nipple.js failed to load!");
                alert("Joystick library blocked by browser/network.\nPlease try a different browser or check internet connection.");
            } else
                initTouchControls();

            loop();
        });
    </script>
</body>

</html>