<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Battleground: Ultimate Edition</title>
    <style>
        body {
            background-color: #050505;
            color: #eee;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-image: radial-gradient(circle at center, #111 0%, #000 100%);
            overflow: hidden;
            user-select: none;
            outline: none;
        }

        .arcade-header {
            width: 960px;
            background: #0a0a0a;
            border: 4px solid #333;
            border-radius: 4px;
            margin-bottom: 20px;
            padding: 15px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            border-bottom: 2px solid #333;
            padding-bottom: 8px;
            margin-bottom: 5px;
        }

        .game-title {
            margin: 0;
            font-size: 2.0em;
            color: #fff;
            letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
            font-weight: 900;
            text-transform: uppercase;
            font-style: italic;
        }

        .round-info {
            color: #f0c040;
            font-size: 1.1em;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(240, 192, 64, 0.5);
            letter-spacing: 1px;
        }

        .instructions-grid {
            display: grid;
            grid-template-columns: 1fr 1.8fr 1fr;
            gap: 10px;
            font-size: 0.85em;
        }

        .player-card {
            text-align: center;
            background: rgba(255, 255, 255, 0.03);
            padding: 8px;
            border-radius: 4px;
        }

        .p1-title {
            color: #00ffff;
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 8px;
            border-bottom: 2px solid #00ffff;
            display: inline-block;
            padding: 0 10px;
        }

        .p2-title {
            color: #ff00ff;
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 8px;
            border-bottom: 2px solid #ff00ff;
            display: inline-block;
            padding: 0 10px;
        }

        .controls-list {
            line-height: 1.6em;
            color: #aaa;
            text-align: left;
            padding-left: 20px;
        }

        .key {
            background: #333;
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #555;
            font-weight: bold;
            font-size: 0.9em;
        }

        .label {
            float: right;
            margin-right: 20px;
            font-size: 0.8em;
            color: #777;
        }

        .mechanics-card {
            text-align: left;
            padding: 0 15px;
            color: #ccc;
            border-left: 2px solid #222;
            border-right: 2px solid #222;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .mech-row {
            margin-bottom: 6px;
            display: flex;
            align-items: center;
        }

        .mech-icon {
            width: 20px;
            display: inline-block;
            text-align: center;
            margin-right: 10px;
            font-weight: bold;
        }

        .highlight-green {
            color: #55ff55;
            font-weight: bold;
        }

        .highlight-red {
            color: #ff5555;
            font-weight: bold;
        }

        .highlight-yellow {
            color: #ffff55;
            font-weight: bold;
        }

        .highlight-blue {
            color: #55ffff;
            font-weight: bold;
        }

        .highlight-orange {
            color: #ffaa00;
            font-weight: bold;
        }

        .highlight-white {
            color: #ffffff;
            font-weight: bold;
        }

        .console-case {
            background: #111;
            padding: 10px;
            border-radius: 2px;
            border: 1px solid #333;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: fit-content;
        }

        .screen-bezel {
            background: #000;
            padding: 0;
            box-shadow: inset 0 0 10px #000;
            z-index: 10;
            position: relative;
        }

        canvas {
            width: 960px;
            aspect-ratio: 2 / 1;
            background-color: #000;
            display: block;
            image-rendering: pixelated;
        }

        .info {
            position: absolute;
            bottom: 20px;
            text-align: center;
            color: #666;
            width: 100%;
            font-size: 0.8em;
        }

        .panel-id {
            position: absolute;
            bottom: -25px;
            right: 0;
            color: #333;
            font-size: 10px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>

<body tabindex="0" onclick="this.focus()">

    <div class="arcade-header">
        <div class="header-top">
            <h1 class="game-title">MAZE BATTLEGROUND</h1>
            <div class="round-info">WIN CONDITION: 5 POINTS</div>
        </div>
        <div class="instructions-grid">
            <div class="player-card">
                <div class="p1-title">PLAYER 1 (LEFT SIDE)</div>
                <div class="controls-list">
                    <span class="key">WASD</span> <span class="label">MOVE</span><br>
                    <span class="key">F</span> <span class="label">BEAM</span><br>
                    <span class="key">G</span> <span class="label">BOOST</span><br>
                    <span class="key">V</span> <span class="label">SHIELD</span><br>
                    <span class="key">H</span> <span class="label">MINE</span><br>
                    <span class="key">J</span> <span class="label">DETONATE</span>
                </div>
            </div>
            <div class="mechanics-card">
                <div class="mech-row"><span class="mech-icon">âœ¦</span> <span><span class="highlight-green">AMMO:</span>
                        Collect green box for mines.</span></div>
                <div class="mech-row"><span class="mech-icon">âš </span> <span><span
                            class="highlight-red">ELIMINATE:</span> Beams STUN enemy.</span></div>
                <div class="mech-row"><span class="mech-icon">ðŸ›¡</span> <span><span
                            class="highlight-white">SHIELD:</span> Blocks all dmg (High Cost).</span></div>
                <div class="mech-row"><span class="mech-icon">â—Ž</span> <span><span
                            class="highlight-orange">GLITCH:</span> Portals may invert controls!</span></div>
            </div>
            <div class="player-card">
                <div class="p2-title">PLAYER 2 (RIGHT SIDE)</div>
                <div class="controls-list">
                    <span class="key">ARROWS</span> <span class="label">MOVE</span><br>
                    <span class="key">K</span> <span class="label">BEAM</span><br>
                    <span class="key">L</span> <span class="label">BOOST</span><br>
                    <span class="key">B</span> <span class="label">SHIELD</span><br>
                    <span class="key">M</span> <span class="label">MINE</span><br>
                    <span class="key">N</span> <span class="label">DETONATE</span>
                </div>
            </div>
        </div>
    </div>

    <div class="console-case">
        <div class="screen-bezel">
            <canvas id="ledMatrix" width="1280" height="640"></canvas>
        </div>
        <div class="panel-id">P2.5-320x160-1/32S</div>
    </div>

    <div class="info">PRESS 'R' TO RESET ROUND / GAME</div>

    <script>
        const canvas = document.getElementById('ledMatrix');
        const ctx = canvas.getContext('2d');

        // --- CONSTANTS ---
        const LOGICAL_W = 128;
        const LOGICAL_H = 64;
        const PITCH = 10;
        const LED_RADIUS = 3.5;

        const HUD_WIDTH = 8;
        const CELL_SIZE = 3;
        const ROWS = 21;
        const COLS = 37;
        const MAZE_PADDING_X = 0; const MAZE_OFFSET_X = HUD_WIDTH + MAZE_PADDING_X;

        const BASE_SPEED = 0.3; const MAX_SPEED = 1.2;
        const BOOST_DRAIN = 100 / (5 * 60);
        const SHIELD_DRAIN = BOOST_DRAIN * 1.5;
        const BOOST_REGEN = BOOST_DRAIN * 0.4;
        const BOOST_COOLDOWN_FRAMES = 60;
        const BEAM_ENERGY_COST = 20;
        const DETONATE_COST = 30;

        const STUN_DURATION = 360;
        const STUN_SPEED_FACTOR = 0.8;
        const GLITCH_CHANCE = 0.3;
        const GLITCH_DURATION = 180;

        const BEAM_LENGTH = 40;
        const MAX_SCORE = 5;

        const MINE_ARM_TIME = 2000;
        const MINE_COOLDOWN = 500;
        const MAX_MINES = 5;
        const PARTICLE_COUNT = 40;
        const TRAIL_LENGTH = 12;

        const AMMO_RESPAWN_DELAY = 300;

        // --- ASSETS ---
        const BITMAP_FONT = { 'A': [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1], 'B': [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], 'C': [0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1], 'D': [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0], 'E': [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], 'F': [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0], 'G': [0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1], 'H': [1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1], 'I': [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], 'J': [0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], 'K': [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1], 'L': [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1], 'M': [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], 'N': [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], 'O': [0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], 'P': [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0], 'Q': [0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1], 'R': [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1], 'S': [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0], 'T': [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], 'U': [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], 'V': [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], 'W': [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1], 'X': [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1], 'Y': [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], 'Z': [1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1], '0': [0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], '1': [0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], '2': [1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1], '3': [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0], '4': [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1], '5': [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], '6': [0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0], '7': [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], '8': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], '9': [0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0], '!': [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], ' ': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "'": [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], '?': [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], '-': [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], '.': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], ',': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0] };
        const DIGITS = { 0: [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1], 1: [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], 2: [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1], 3: [1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1], 4: [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1], 5: [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1], 6: [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], 7: [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 8: [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1], 9: [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1] };
        const TAUNTS = ["YOUR MOTHER WAS A HAMSTER!", "I FART IN YOUR GENERAL DIRECTION!", "GO AWAY OR I SHALL TAUNT YOU AGAIN!", "YOU FIGHT LIKE A DAIRY FARMER!", "TIS BUT A SCRATCH!", "RUN AWAY! RUN AWAY!", "MY HOVERCRAFT IS FULL OF EELS!", "YOU EMPTY-HEADED ANIMAL!"];

        // --- GAME STATE ---
        let maze = [];
        let wallHue = 0;
        let isGameOver = false;
        let isRoundOver = false;
        let winMessage = "";
        let tauntMessage = "";
        let roundMessage = "";
        let winColor = "#fff";
        let roundColor = "#fff";
        let scrollX = 0;
        let gameTime = 0;
        let maxGameTime = 0;
        let ammoCrate = null;
        let ammoRespawnTimer = 0;
        let mines = [];
        let particles = [];
        let portals = [];
        const keys = {};

        const players = [
            { x: 0, y: 0, color: '#00ffff', size: 2.0, score: 0, beamPixels: [], beamIdx: 0, goalC: COLS - 1, goalR: ROWS - 1, lastMineTime: 0, minesLeft: 3, trail: [], boostEnergy: 100, boostCooldown: 0, portalCooldown: 0, stunTime: 0, glitchTime: 0, prevDetonateKey: false, shieldActive: false },
            { x: 0, y: 0, color: '#ff00ff', size: 2.0, score: 0, beamPixels: [], beamIdx: 0, goalC: 0, goalR: 0, lastMineTime: 0, minesLeft: 3, trail: [], boostEnergy: 100, boostCooldown: 0, portalCooldown: 0, stunTime: 0, glitchTime: 0, prevDetonateKey: false, shieldActive: false }
        ];

        // --- CLASSES & UTILS ---
        class Cell { constructor(c, r) { this.c = c; this.r = r; this.walls = [true, true, true, true]; this.visited = false; this.parent = null; this.bfsVisited = false; } checkNeighbors() { let neighbors = []; let top = gridIndex(this.c, this.r - 1); let right = gridIndex(this.c + 1, this.r); let bottom = gridIndex(this.c, this.r + 1); let left = gridIndex(this.c - 1, this.r); if (top && !top.visited) neighbors.push(top); if (right && !right.visited) neighbors.push(right); if (bottom && !bottom.visited) neighbors.push(bottom); if (left && !left.visited) neighbors.push(left); return (neighbors.length > 0) ? neighbors[Math.floor(Math.random() * neighbors.length)] : undefined; } }
        function gridIndex(c, r) { if (c < 0 || r < 0 || c >= COLS || r >= ROWS) return undefined; return maze[c + r * COLS]; }
        function removeWalls(a, b) { let x = a.c - b.c; if (x === 1) { a.walls[3] = false; b.walls[1] = false; } if (x === -1) { a.walls[1] = false; b.walls[3] = false; } let y = a.r - b.r; if (y === 1) { a.walls[0] = false; b.walls[2] = false; } if (y === -1) { a.walls[2] = false; b.walls[0] = false; } }

        // --- INITIALIZATION ---
        function initMaze() {
            maze = []; let stack = []; for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) maze.push(new Cell(c, r));
            let current = maze[0]; current.visited = true;
            while (true) { let next = current.checkNeighbors(); if (next) { next.visited = true; stack.push(current); removeWalls(current, next); current = next; } else if (stack.length > 0) current = stack.pop(); else break; }

            // Reset Player States
            players[0].x = MAZE_OFFSET_X + 1; players[0].y = 1;
            players[1].x = MAZE_OFFSET_X + ((COLS - 1) * CELL_SIZE) + 1; players[1].y = ((ROWS - 1) * CELL_SIZE) + 1;

            players.forEach(p => {
                p.trail = []; p.boostEnergy = 100; p.boostCooldown = 0;
                p.portalCooldown = 0; p.stunTime = 0; p.glitchTime = 0;
                p.shieldActive = false; p.minesLeft = MAX_MINES; p.beamPixels = [];
            });

            mines = []; particles = []; portals = [];

            generatePortals();
            ammoCrate = null; spawnAmmoCrate();
            calculateInitialTime();
            isRoundOver = false;
        }

        function generatePortals() {
            portals = [];
            let attempts = 0;
            while (portals.length < 2 && attempts < 100) {
                let c = Math.floor(Math.random() * (COLS - 2)) + 1;
                let r = Math.floor(Math.random() * (ROWS - 2)) + 1;
                if ((c < 5 && r < 5) || (c > COLS - 5 && r > ROWS - 5)) continue;
                let tooClose = false;
                for (let p of portals) { if (Math.abs(p.c - c) + Math.abs(p.r - r) < 10) tooClose = true; }
                if (tooClose) continue;
                let px = MAZE_OFFSET_X + (c * CELL_SIZE) + (CELL_SIZE / 2) - 0.5;
                let py = (r * CELL_SIZE) + (CELL_SIZE / 2) - 0.5;
                portals.push({ c: c, r: r, x: px, y: py, color: portals.length === 0 ? '#ffaa00' : '#00aaff' });
            }
        }

        function spawnAmmoCrate() {
            let attempts = 0;
            while (attempts < 50) {
                let c = Math.floor(Math.random() * (COLS - 2)) + 1;
                let r = Math.floor(Math.random() * (ROWS - 2)) + 1;
                if ((c < 5 && r < 5) || (c > COLS - 5 && r > ROWS - 5)) continue;
                let occupied = portals.find(p => p.c === c && p.r === r);
                if (occupied) continue;
                let px = MAZE_OFFSET_X + (c * CELL_SIZE) + (CELL_SIZE / 2) - 1.0;
                let py = (r * CELL_SIZE) + (CELL_SIZE / 2) - 1.0;
                ammoCrate = { x: px, y: py, c: c, r: r };
                break;
            }
        }

        function calculateInitialTime() {
            let start = gridIndex(0, 0); let end = gridIndex(COLS - 1, ROWS - 1);
            for (let i = 0; i < maze.length; i++) { maze[i].bfsVisited = false; maze[i].parent = null; }
            let queue = [start]; start.bfsVisited = true; let pathLengthCells = 0; let found = false;
            while (queue.length > 0) {
                let curr = queue.shift(); if (curr === end) { found = true; break; }
                let neighbors = [{ cell: gridIndex(curr.c, curr.r - 1), wall: curr.walls[0] }, { cell: gridIndex(curr.c + 1, curr.r), wall: curr.walls[1] }, { cell: gridIndex(curr.c, curr.r + 1), wall: curr.walls[2] }, { cell: gridIndex(curr.c - 1, curr.r), wall: curr.walls[3] }];
                for (let n of neighbors) { if (n.cell && !n.cell.bfsVisited && !n.wall) { n.cell.bfsVisited = true; n.cell.parent = curr; queue.push(n.cell); } }
            }
            if (found) { let temp = end; while (temp) { pathLengthCells++; temp = temp.parent; } }
            let distancePixels = pathLengthCells * CELL_SIZE; let estimatedSpeed = (BASE_SPEED + MAX_SPEED) / 2;
            gameTime = Math.floor((distancePixels / estimatedSpeed) * 6); maxGameTime = gameTime;
        }

        // --- DRAWING FUNCTIONS ---
        function drawLED(lx, ly, color) {
            const centerX = (lx * PITCH) + (PITCH / 2); const centerY = (ly * PITCH) + (PITCH / 2);
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(centerX, centerY, LED_RADIUS, 0, Math.PI * 2); ctx.fill();
        }

        function drawText(str, x, y, color) {
            str = str.toUpperCase(); let cursorX = x;
            for (let i = 0; i < str.length; i++) {
                let char = str[i]; let map = BITMAP_FONT[char];
                if (map) { for (let p = 0; p < 15; p++) { if (map[p] === 1) { let col = p % 3; let row = Math.floor(p / 3); drawLED(cursorX + col, y + row, color); } } }
                cursorX += 4;
            }
        }

        function drawDigit(x, y, num, color, rotateDeg) {
            const map = DIGITS[num]; const w = 3; const h = 5;
            for (let i = 0; i < 15; i++) {
                if (map[i] === 1) {
                    let col = i % 3; let row = Math.floor(i / 3);
                    let dx, dy;
                    if (rotateDeg === -90) { dx = row; dy = (w - 1 - col); } else if (rotateDeg === 90) { dx = (h - 1 - row); dy = col; } else { dx = col; dy = row; }
                    drawLED(x + dx, y + dy, color);
                }
            }
        }

        function drawHUD(wallColor) {
            let p1 = players[0]; let p2 = players[1];
            let p1s = p1.score.toString().padStart(2, '0'); let p2s = p2.score.toString().padStart(2, '0');
            let seconds = Math.ceil(gameTime / 60).toString().padStart(3, '0');
            let timeRatio = Math.max(0, Math.min(1, gameTime / maxGameTime));
            let clockHue = Math.floor(timeRatio * 180); let clockColor = `hsl(${clockHue}, 100%, 50%)`;

            // P1 HUD
            drawDigit(0, 0, parseInt(p1s[0]), '#00ffff', 90); drawDigit(0, 4, parseInt(p1s[1]), '#00ffff', 90);
            let b1MineHue = Math.floor((p1.minesLeft / 5) * 120);
            let b1MineColor = `hsl(${b1MineHue}, 100%, 50%)`;
            drawDigit(0, 10, parseInt(p1.minesLeft), b1MineColor, 90);//for(let i=0; i<5; i++) { let c = (i < p1.minesLeft) ? p1.color : '#222'; drawLED(0 + (i), 8 , c); }
            let b1MaxH = 38; let b1H = Math.floor((p1.boostEnergy / 100) * b1MaxH); let b1Hue = Math.floor((p1.boostEnergy / 100) * 120); let b1Color = `hsl(${b1Hue}, 100%, 50%)`;
            for (let h = 0; h < b1H; h++) { for (let w = 0; w < 5; w++) drawLED(w, 14 + h, b1Color); }
            drawDigit(0, 53, parseInt(seconds[0]), clockColor, 90); drawDigit(0, 57, parseInt(seconds[1]), clockColor, 90); drawDigit(0, 61, parseInt(seconds[2]), clockColor, 90);

            // P2 HUD
            let rx = 123;
            drawDigit(rx, 61, parseInt(p2s[0]), '#ff00ff', -90); drawDigit(rx, 57, parseInt(p2s[1]), '#ff00ff', -90);
            let b2MineHue = Math.floor((p1.minesLeft / 5) * 120);
            let b2MineColor = `hsl(${b2MineHue}, 100%, 50%)`;
            drawDigit(rx, 51, parseInt(p2.minesLeft), b2MineColor, -90);//for(let i=0; i<5; i++) { let c = (i < p2.minesLeft) ? p2.color : '#222'; drawLED(rx + 4 - (i) , 55 , c); }
            let b2H = Math.floor((p2.boostEnergy / 100) * b1MaxH); let b2Hue = Math.floor((p2.boostEnergy / 100) * 120); let b2Color = `hsl(${b2Hue}, 100%, 50%)`;
            for (let h = 0; h < b2H; h++) { for (let w = 0; w < 5; w++) drawLED(rx + w, 49 - h, b2Color); }
            drawDigit(rx, 8, parseInt(seconds[0]), clockColor, -90); drawDigit(rx, 4, parseInt(seconds[1]), clockColor, -90); drawDigit(rx, 0, parseInt(seconds[2]), clockColor, -90);
        }

        function drawEntities(wallColor) {
            // Draw Maze
            for (let i = 0; i < maze.length; i++) {
                let cell = maze[i]; let x = (cell.c * CELL_SIZE) + MAZE_OFFSET_X; let y = cell.r * CELL_SIZE;
                drawLED(x, y, wallColor);
                if (cell.walls[0]) { drawLED(x + 1, y, wallColor); drawLED(x + 2, y, wallColor); }
                if (cell.walls[3]) { drawLED(x, y + 1, wallColor); drawLED(x, y + 2, wallColor); }
                if (cell.c === COLS - 1) { drawLED(x + 3, y, wallColor); if (cell.walls[1]) { drawLED(x + 3, y + 1, wallColor); drawLED(x + 3, y + 2, wallColor); } }
                if (cell.r === ROWS - 1) { drawLED(x, y + 3, wallColor); if (cell.walls[2]) { drawLED(x + 1, y + 3, wallColor); drawLED(x + 2, y + 3, wallColor); } }
                if (cell.c === COLS - 1 && cell.r === ROWS - 1) drawLED(x + 3, y + 3, wallColor);
            }

            // Draw Portals
            portals.forEach(p => {
                let pulse = Math.abs(Math.sin(Date.now() / 300));
                ctx.globalAlpha = 0.5 + (0.5 * pulse);
                drawLED(p.x, p.y, p.color); drawLED(p.x + 1, p.y, p.color); drawLED(p.x, p.y + 1, p.color); drawLED(p.x + 1, p.y + 1, p.color);
                ctx.globalAlpha = 1.0;
            });

            // Draw Ammo
            if (ammoCrate) {
                let pulse = Math.abs(Math.sin(Date.now() / 200));
                ctx.globalAlpha = 0.8 + (0.2 * pulse);
                drawLED(ammoCrate.x, ammoCrate.y, '#00ff00'); drawLED(ammoCrate.x + 1, ammoCrate.y, '#00ff00');
                drawLED(ammoCrate.x, ammoCrate.y + 1, '#00ff00'); drawLED(ammoCrate.x + 1, ammoCrate.y + 1, '#00ff00');
                ctx.globalAlpha = 1.0;
            }

            // Draw Mines
            mines.forEach(m => {
                let flash = Math.floor(Date.now() / 100) % 2 === 0;
                let color = m.active ? (flash ? '#ff0000' : '#880000') : '#444444';
                drawLED(m.x + m.visX, m.y + m.visY, color);
            });

            // Draw Players & Beams
            players.forEach(p => {
                // Color Logic
                if (p.stunTime > 0) {
                    if (Math.floor(Date.now() / 50) % 2 === 0) p.color = '#880088'; else p.color = p === players[0] ? '#00ffff' : '#ff00ff';
                } else if (p.glitchTime > 0) {
                    if (Math.floor(Date.now() / 50) % 2 === 0) p.color = '#00ff00'; else p.color = p === players[0] ? '#00ffff' : '#ff00ff';
                } else {
                    p.color = p === players[0] ? '#00ffff' : '#ff00ff';
                }

                // Beams
                if (p.beamIdx < p.beamPixels.length + BEAM_LENGTH) {
                    for (let k = 0; k < BEAM_LENGTH; k++) {
                        let i = Math.floor(p.beamIdx) - k;
                        if (i >= 0 && i < p.beamPixels.length) {
                            let point = p.beamPixels[i]; ctx.globalAlpha = 1.0 - (k / BEAM_LENGTH); drawLED(point.x, point.y, p.color); ctx.globalAlpha = 1.0;
                        }
                    }
                }
            });

            // Particles
            particles.forEach((p, idx) => {
                drawLED(p.x, p.y, p.color);
                p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                if (p.life <= 0) particles.splice(idx, 1);
            });

            // Player Bodies & Shields
            players.forEach(p => {
                if (p.shieldActive) {
                    let sx = Math.floor(p.x) - 1; let sy = Math.floor(p.y) - 1; let size = 4;
                    for (let i = 0; i < size; i++) {
                        drawLED(sx + i, sy, '#8888ff'); drawLED(sx + i, sy + size - 1, '#8888ff');
                        drawLED(sx, sy + i, '#8888ff'); drawLED(sx + size - 1, sy + i, '#8888ff');
                    }
                }
                if (p.portalCooldown > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;

                // Trail
                let speedFactor = (p.boostEnergy > 0 && (p.currentSpeed > BASE_SPEED)) ? 1.0 : 0.0;
                if (speedFactor > 0) {
                    p.trail.forEach((pos, index) => {
                        let fade = (index / p.trail.length) * 0.5; ctx.globalAlpha = fade;
                        for (let py = 0; py < p.size; py++) for (let px = 0; px < p.size; px++) drawLED(Math.floor(pos.x + px), Math.floor(pos.y + py), p.color);
                        ctx.globalAlpha = 1.0;
                    });
                }
                // Body
                for (let py = 0; py < p.size; py++) for (let px = 0; px < p.size; px++) drawLED(Math.floor(p.x + px), Math.floor(p.y + py), p.color);
            });
        }

        // --- GAME LOGIC ---
        function handleInput() {
            // P1
            let p1 = players[0];
            if (keys['j'] && !p1.prevDetonateKey) { manualDetonate(0); }
            p1.prevDetonateKey = keys['j'];

            if (keys['v'] && p1.boostEnergy > 0) { p1.shieldActive = true; p1.boostEnergy -= SHIELD_DRAIN; } else { p1.shieldActive = false; }

            let s1 = BASE_SPEED;
            if (p1.stunTime > 0) {
                s1 = BASE_SPEED * STUN_SPEED_FACTOR; if (!keys['g'] && !p1.shieldActive) p1.boostEnergy = Math.min(100, p1.boostEnergy + BOOST_REGEN);
            } else {
                if (p1.boostCooldown > 0) { p1.boostCooldown--; if (!p1.shieldActive) p1.boostEnergy = Math.min(100, p1.boostEnergy + BOOST_REGEN); s1 = BASE_SPEED; }
                else {
                    if (keys['g']) { if (p1.boostEnergy > 0) { p1.boostEnergy -= BOOST_DRAIN; s1 = MAX_SPEED; if (p1.boostEnergy <= 0) p1.boostEnergy = 0; } else { s1 = BASE_SPEED; } }
                    else { if (p1.boostEnergy <= 0) p1.boostCooldown = BOOST_COOLDOWN_FRAMES; else if (!p1.shieldActive) p1.boostEnergy = Math.min(100, p1.boostEnergy + BOOST_REGEN); }
                }
            }
            p1.currentSpeed = s1;
            if (keys['w']) performMove(p1, 0, -s1); if (keys['s']) performMove(p1, 0, s1); if (keys['a']) performMove(p1, -s1, 0); if (keys['d']) performMove(p1, s1, 0);
            if (keys['h']) dropMine(0); if (keys['f']) fireBeam(0);

            // P2
            let p2 = players[1];
            if (keys['n'] && !p2.prevDetonateKey) { manualDetonate(1); }
            p2.prevDetonateKey = keys['n'];

            if (keys['b'] && p2.boostEnergy > 0) { p2.shieldActive = true; p2.boostEnergy -= SHIELD_DRAIN; } else { p2.shieldActive = false; }

            let s2 = BASE_SPEED;
            if (p2.stunTime > 0) {
                s2 = BASE_SPEED * STUN_SPEED_FACTOR; if (!keys['l'] && !p2.shieldActive) p2.boostEnergy = Math.min(100, p2.boostEnergy + BOOST_REGEN);
            } else {
                if (p2.boostCooldown > 0) { p2.boostCooldown--; if (!p2.shieldActive) p2.boostEnergy = Math.min(100, p2.boostEnergy + BOOST_REGEN); s2 = BASE_SPEED; }
                else {
                    if (keys['l']) { if (p2.boostEnergy > 0) { p2.boostEnergy -= BOOST_DRAIN; s2 = MAX_SPEED; if (p2.boostEnergy <= 0) p2.boostEnergy = 0; } else { s2 = BASE_SPEED; } }
                    else { if (p2.boostEnergy <= 0) p2.boostCooldown = BOOST_COOLDOWN_FRAMES; else if (!p2.shieldActive) p2.boostEnergy = Math.min(100, p2.boostEnergy + BOOST_REGEN); }
                }
            }
            p2.currentSpeed = s2;
            if (keys['arrowup']) performMove(p2, 0, -s2); if (keys['arrowdown']) performMove(p2, 0, s2); if (keys['arrowleft']) performMove(p2, -s2, 0); if (keys['arrowright']) performMove(p2, s2, 0);
            if (keys['m']) dropMine(1); if (keys['k']) fireBeam(1);
        }

        function update() {
            if (gameTime <= 0) { triggerRoundWin(-1); return; }
            gameTime -= 1; wallHue = (wallHue + 0.5) % 360;

            let now = Date.now();
            for (let i = 0; i < mines.length; i++) {
                let m = mines[i];
                if (!m.active && now - m.droppedAt > MINE_ARM_TIME) m.active = true;
            }

            if (!ammoCrate) { ammoRespawnTimer++; if (ammoRespawnTimer > AMMO_RESPAWN_DELAY) { spawnAmmoCrate(); ammoRespawnTimer = 0; } }

            let p1 = players[0]; let p2 = players[1];
            let b1Idx = Math.floor(p1.beamIdx); let b2Idx = Math.floor(p2.beamIdx);

            if (p1.beamPixels.length > 0 && p2.beamPixels.length > 0 && b1Idx < p1.beamPixels.length && b2Idx < p2.beamPixels.length) {
                let h1 = p1.beamPixels[b1Idx]; let h2 = p2.beamPixels[b2Idx];
                let dist = Math.abs(h1.x - h2.x) + Math.abs(h1.y - h2.y);
                if (dist < 4) { triggerExplosion((h1.x + h2.x) / 2, (h1.y + h2.y) / 2); p1.beamPixels = []; p1.beamIdx = 9999; p2.beamPixels = []; p2.beamIdx = 9999; }
            }

            players.forEach((p, idx) => {
                if (ammoCrate) {
                    let px = p.x + 1; let py = p.y + 1;
                    if (Math.abs(px - (ammoCrate.x + 1)) < 2 && Math.abs(py - (ammoCrate.y + 1)) < 2) { p.minesLeft = MAX_MINES; ammoCrate = null; ammoRespawnTimer = 0; }
                }

                if (p.stunTime > 0) p.stunTime--;
                if (p.glitchTime > 0) p.glitchTime--;

                if (p.portalCooldown > 0) p.portalCooldown--;
                else {
                    let pCenterC = Math.floor((p.x + p.size / 2 - MAZE_OFFSET_X) / CELL_SIZE);
                    let pCenterR = Math.floor((p.y + p.size / 2) / CELL_SIZE);
                    for (let portal of portals) {
                        if (pCenterC === portal.c && pCenterR === portal.r) {
                            let dest = portals.find(pt => pt !== portal);
                            if (dest) {
                                p.x = MAZE_OFFSET_X + (dest.c * CELL_SIZE) + (CELL_SIZE - p.size) / 2;
                                p.y = (dest.r * CELL_SIZE) + (CELL_SIZE - p.size) / 2;
                                p.portalCooldown = 60;
                                if (Math.random() < GLITCH_CHANCE) { p.glitchTime = GLITCH_DURATION; }
                                for (let i = 0; i < 10; i++) particles.push({ x: portal.x + 1, y: portal.y + 1, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, life: 0.5, color: '#fff' });
                                for (let i = 0; i < 10; i++) particles.push({ x: dest.x + 1, y: dest.y + 1, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, life: 0.5, color: '#fff' });
                                break;
                            }
                        }
                    }
                }

                p.trail.push({ x: p.x, y: p.y }); if (p.trail.length > TRAIL_LENGTH) p.trail.shift();
                if (p.beamIdx < p.beamPixels.length + BEAM_LENGTH) p.beamIdx += 0.8;

                let opponent = players[(idx + 1) % 2];
                let tipIndex = Math.floor(opponent.beamIdx);
                if (tipIndex >= 0 && tipIndex < opponent.beamPixels.length) {
                    let tip = opponent.beamPixels[tipIndex];
                    if (Math.abs(p.x - tip.x) < 1.5 && Math.abs(p.y - tip.y) < 1.5) {
                        if (!p.shieldActive) { p.stunTime = STUN_DURATION; }
                        opponent.beamPixels = []; opponent.beamIdx = 9999;
                    }
                }

                for (let i = mines.length - 1; i >= 0; i--) {
                    let m = mines[i];
                    let bIdx = Math.floor(p.beamIdx);
                    if (bIdx >= 0 && bIdx < p.beamPixels.length) {
                        let bp = p.beamPixels[bIdx];
                        if (bp.x >= m.x - 1 && bp.x <= m.x + 3 && bp.y >= m.y - 1 && bp.y <= m.y + 3) {
                            triggerExplosion(m.x, m.y); mines.splice(i, 1); p.beamPixels = []; p.beamIdx = 9999; continue;
                        }
                    }
                    if (m.active) {
                        if (p.x + p.size > m.x && p.x < m.x + 2 && p.y + p.size > m.y && p.y < m.y + 2) {
                            triggerExplosion(m.x, m.y);
                            if (!p.shieldActive) { p.stunTime = STUN_DURATION; }
                        }
                    }
                }
            });

            handleInput();

            if (checkGoal(players[0])) { players[0].score++; if (players[0].score >= MAX_SCORE) triggerWin(0); else triggerRoundWin(0); }
            else if (checkGoal(players[1])) { players[1].score++; if (players[1].score >= MAX_SCORE) triggerWin(1); else triggerRoundWin(1); }
        }

        // --- HELPER FUNCTIONS (Collision, Etc) ---
        function manualDetonate(playerIndex) {
            let p = players[playerIndex]; if (p.boostEnergy < DETONATE_COST) return;
            let minesFound = false;
            for (let i = mines.length - 1; i >= 0; i--) {
                if (mines[i].owner === playerIndex) { triggerExplosion(mines[i].x, mines[i].y); mines.splice(i, 1); minesFound = true; }
            }
            if (minesFound) { p.boostEnergy -= DETONATE_COST; }
        }

        function destroyWallAt(c, r) {
            if (c <= 0 || c >= COLS - 1 || r <= 0 || r >= ROWS - 1) return;
            let center = gridIndex(c, r);
            if (center) {
                center.walls = [false, false, false, false];
                let top = gridIndex(c, r - 1); if (top) top.walls[2] = false;
                let right = gridIndex(c + 1, r); if (right) right.walls[3] = false;
                let bottom = gridIndex(c, r + 1); if (bottom) bottom.walls[0] = false;
                let left = gridIndex(c - 1, r); if (left) left.walls[1] = false;
            }
        }

        function triggerExplosion(x, y) {
            let gridC = Math.floor((x - MAZE_OFFSET_X) / CELL_SIZE); let gridR = Math.floor(y / CELL_SIZE);
            destroyWallAt(gridC, gridR);
            for (let i = 0; i < PARTICLE_COUNT; i++) { particles.push({ x: x + 1, y: y + 1, vx: (Math.random() - 0.5) * 2.5, vy: (Math.random() - 0.5) * 2.5, life: 1.0, color: Math.random() > 0.5 ? '#ffff00' : '#ff4400' }); }
        }

        function isWall(pixelX, pixelY) {
            if (pixelX < MAZE_OFFSET_X || pixelX >= LOGICAL_W - HUD_WIDTH) return true;
            if (pixelY < 0 || pixelY >= LOGICAL_H) return true;
            let mx = pixelX - MAZE_OFFSET_X; let my = pixelY;
            let col = Math.floor(mx / CELL_SIZE); let row = Math.floor(my / CELL_SIZE);
            let cell = gridIndex(col, row);
            if (!cell) return true;
            let lx = Math.floor(mx) % CELL_SIZE; let ly = Math.floor(my) % CELL_SIZE;
            if (lx === 0 && ly === 0) return true; if (ly === 0 && cell.walls[0]) return true; if (lx === 0 && cell.walls[3]) return true;
            return false;
        }

        function checkPlayerCollision(p, dx, dy) {
            let nextX = p.x + dx; let nextY = p.y + dy; let padding = 0.6; let hitboxSize = 0.8;
            let x1 = nextX + padding; let y1 = nextY + padding; let x2 = x1 + hitboxSize; let y2 = y1 + hitboxSize;
            if (isWall(x1, y1) || isWall(x2, y1) || isWall(x1, y2) || isWall(x2, y2)) return true;
            return false;
        }

        function performMove(p, dx, dy) {
            if (p.glitchTime > 0) { dx = -dx; dy = -dy; }
            let dist = Math.hypot(dx, dy); let stepSize = 0.5; let stepCount = Math.ceil(dist / stepSize);
            let sx = dx / stepCount; let sy = dy / stepCount;
            for (let i = 0; i < stepCount; i++) {
                if (sx !== 0) { if (!checkPlayerCollision(p, sx, 0)) { p.x += sx; } }
                if (sy !== 0) { if (!checkPlayerCollision(p, 0, sy)) { p.y += sy; } }
            }
        }

        function checkGoal(p) {
            let gx = MAZE_OFFSET_X + (p.goalC * CELL_SIZE) + 1; let gy = (p.goalR * CELL_SIZE) + 1;
            if (Math.abs(p.x - gx) < 1.0 && Math.abs(p.y - gy) < 1.0) return true; return false;
        }

        function triggerWin(playerIndex) {
            isGameOver = true; winColor = players[playerIndex].color;
            winMessage = `PLAYER ${playerIndex + 1} WINS!`; tauntMessage = TAUNTS[Math.floor(Math.random() * TAUNTS.length)]; scrollX = LOGICAL_W + 5;
        }

        function triggerRoundWin(playerIndex) {
            isRoundOver = true;
            if (playerIndex === -1) { roundMessage = "TIME OUT!"; roundColor = "#ffff00"; }
            else { roundMessage = `PLAYER ${playerIndex + 1} SCORES!`; roundColor = players[playerIndex].color; }
            scrollX = LOGICAL_W + 5;
        }

        function resetGame() { players[0].score = 0; players[1].score = 0; isGameOver = false; initMaze(); }
        function setKey(k, state) { keys[k.toLowerCase()] = state; }

        function loop() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < LOGICAL_H; y++) for (let x = 0; x < LOGICAL_W; x++) drawLED(x, y, '#222');

            if (isGameOver) {
                let flash = Math.floor(Date.now() / 200) % 2 === 0;
                if (flash) drawText(winMessage, 10, 15, winColor);
                drawText(tauntMessage, scrollX, 35, "#ff5555"); drawText("PRESS 'R'", 40, 52, "#888");
                scrollX -= 0.5; if (scrollX < - (tauntMessage.length * 4.5)) scrollX = LOGICAL_W;
            }
            else if (isRoundOver) {
                let flash = Math.floor(Date.now() / 200) % 2 === 0;
                if (flash) drawText("ROUND OVER", 10, 20, "#fff");
                drawText(roundMessage, scrollX, 40, roundColor);
                scrollX -= 0.5; if (scrollX < - (roundMessage.length * 4.5)) scrollX = LOGICAL_W;
            }
            else {
                let timeRatio = Math.max(0, Math.min(1, gameTime / maxGameTime));
                wallHue = Math.floor(timeRatio * 180);
                let wallColor = `hsl(${wallHue}, 100%, 50%)`;
                drawEntities(wallColor); drawHUD(wallColor);
                update();
            }
            requestAnimationFrame(loop);
        }

        window.addEventListener('keydown', (e) => {
            let k = e.key.toLowerCase(); keys[k] = true;
            if (isGameOver) { if (k === 'r') resetGame(); }
            else if (isRoundOver) { initMaze(); }
        });
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        window.addEventListener('blur', () => { for (let k in keys) keys[k] = false; });

        initMaze(); loop();
        window.focus();
    </script>
</body>

</html>